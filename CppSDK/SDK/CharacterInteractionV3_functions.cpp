#pragma once

/*
* SDK generated by Rei-SdkDumper
* Based on Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: CharacterInteractionV3

#include "Basic.hpp"

#include "CharacterInteractionV3_classes.hpp"
#include "CharacterInteractionV3_parameters.hpp"


namespace SDK
{

// Function CharacterInteractionV3.ActorOperateAct.OnPause
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AInteractionSkeletalActorV3*      Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorOperateAct::OnPause(class AInteractionSkeletalActorV3* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorOperateAct", "OnPause");

	Params::ActorOperateAct_OnPause Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ActorOperateAct.OnRestart
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AInteractionSkeletalActorV3*      Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorOperateAct::OnRestart(class AInteractionSkeletalActorV3* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorOperateAct", "OnRestart");

	Params::ActorOperateAct_OnRestart Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ActorOperateAct.OnResume
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AInteractionSkeletalActorV3*      Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorOperateAct::OnResume(class AInteractionSkeletalActorV3* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorOperateAct", "OnResume");

	Params::ActorOperateAct_OnResume Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ActorOperateAct.OnStart
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AInteractionSkeletalActorV3*      Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorOperateAct::OnStart(class AInteractionSkeletalActorV3* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorOperateAct", "OnStart");

	Params::ActorOperateAct_OnStart Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ActorOperateAct.OnStartBlendOut
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AInteractionSkeletalActorV3*      Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorOperateAct::OnStartBlendOut(class AInteractionSkeletalActorV3* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorOperateAct", "OnStartBlendOut");

	Params::ActorOperateAct_OnStartBlendOut Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ActorOperateAct.OnStop
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AInteractionSkeletalActorV3*      Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorOperateAct::OnStop(class AInteractionSkeletalActorV3* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorOperateAct", "OnStop");

	Params::ActorOperateAct_OnStop Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ActorOperateAct.OnUpdate
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UInteractionV3InputControl*       InputControl                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AInteractionSkeletalActorV3*      Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorOperateAct::OnUpdate(class UInteractionV3InputControl* InputControl, class AInteractionSkeletalActorV3* Actor, float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorOperateAct", "OnUpdate");

	Params::ActorOperateAct_OnUpdate Parms{};

	Parms.InputControl = InputControl;
	Parms.Actor = Actor;
	Parms.DeltaSeconds = DeltaSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ActorOperateAct.ProcessStartAct
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class AInteractionSkeletalActorV3*      Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorOperateAct::ProcessStartAct(class AInteractionSkeletalActorV3* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorOperateAct", "ProcessStartAct");

	Params::ActorOperateAct_ProcessStartAct Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ActorOperateAct.GetInputControl
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInteractionV3InputControl*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractionV3InputControl* UActorOperateAct::GetInputControl() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorOperateAct", "GetInputControl");

	Params::ActorOperateAct_GetInputControl Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ActorOperateAct.GetScenarioOperate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UScenarioOperate*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UScenarioOperate* UActorOperateAct::GetScenarioOperate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorOperateAct", "GetScenarioOperate");

	Params::ActorOperateAct_GetScenarioOperate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ActorOperateAct.IsCompleteAndBlendOut
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActorOperateAct::IsCompleteAndBlendOut() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorOperateAct", "IsCompleteAndBlendOut");

	Params::ActorOperateAct_IsCompleteAndBlendOut Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionV3Event.DoAction
// (Native, Event, Public, BlueprintEvent)

void UInteractionV3Event::DoAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionV3Event", "DoAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionV3Event.CanTrigger
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionV3Event::CanTrigger() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionV3Event", "CanTrigger");

	Params::InteractionV3Event_CanTrigger Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionV3PhysicsControlComponent.ConditionalCreateMaintainWorldSpaceRelativeControl
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMeshComponent*                   ParentMeshComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       ParentBoneName                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMeshComponent*                   ChildMeshComponent                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       ChildBoneName                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       Set                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       AdditionalSetName                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionV3PhysicsControlComponent::ConditionalCreateMaintainWorldSpaceRelativeControl(class FName Name_0, class UMeshComponent* ParentMeshComponent, const class FName ParentBoneName, class UMeshComponent* ChildMeshComponent, const class FName ChildBoneName, const class FName Set, const class FName AdditionalSetName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionV3PhysicsControlComponent", "ConditionalCreateMaintainWorldSpaceRelativeControl");

	Params::InteractionV3PhysicsControlComponent_ConditionalCreateMaintainWorldSpaceRelativeControl Parms{};

	Parms.Name_0 = Name_0;
	Parms.ParentMeshComponent = ParentMeshComponent;
	Parms.ParentBoneName = ParentBoneName;
	Parms.ChildMeshComponent = ChildMeshComponent;
	Parms.ChildBoneName = ChildBoneName;
	Parms.Set = Set;
	Parms.AdditionalSetName = AdditionalSetName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionV3PhysicsControlComponent.ConditionalDestroyAllMaintainWorldSpaceRelativeControls
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionV3PhysicsControlComponent::ConditionalDestroyAllMaintainWorldSpaceRelativeControls()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionV3PhysicsControlComponent", "ConditionalDestroyAllMaintainWorldSpaceRelativeControls");

	Params::InteractionV3PhysicsControlComponent_ConditionalDestroyAllMaintainWorldSpaceRelativeControls Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionMouseHoverInterface.OnMouseHover
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// const TArray<class FName>&              BoneNames                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const class UCurveFloat*                CurveScale                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector2D&                 SlideVector                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector2D&                 SlideStartPos                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector2D&                 SlidEndPos                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IInteractionMouseHoverInterface::OnMouseHover(const TArray<class FName>& BoneNames, const class UCurveFloat* CurveScale, const struct FVector2D& SlideVector, const struct FVector2D& SlideStartPos, const struct FVector2D& SlidEndPos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("InteractionMouseHoverInterface", "OnMouseHover");

	Params::InteractionMouseHoverInterface_OnMouseHover Parms{};

	Parms.BoneNames = std::move(BoneNames);
	Parms.CurveScale = CurveScale;
	Parms.SlideVector = std::move(SlideVector);
	Parms.SlideStartPos = std::move(SlideStartPos);
	Parms.SlidEndPos = std::move(SlidEndPos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioLittleGameBase.Exit
// (Native, Public, BlueprintCallable)

void UScenarioLittleGameBase::Exit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioLittleGameBase", "Exit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioLittleGameBase.Initialize
// (Native, Public, BlueprintCallable)

void UScenarioLittleGameBase::Initialize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioLittleGameBase", "Initialize");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioLittleGameBase.OnExit
// (Native, Event, Public, BlueprintEvent)

void UScenarioLittleGameBase::OnExit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioLittleGameBase", "OnExit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioLittleGameBase.OnInitialize
// (Native, Event, Public, BlueprintEvent)

void UScenarioLittleGameBase::OnInitialize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioLittleGameBase", "OnInitialize");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioLittleGameBase.OnStart
// (Native, Event, Public, BlueprintEvent)

void UScenarioLittleGameBase::OnStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioLittleGameBase", "OnStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioLittleGameBase.OnUpdate
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScenarioLittleGameBase::OnUpdate(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioLittleGameBase", "OnUpdate");

	Params::ScenarioLittleGameBase_OnUpdate Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioLittleGameBase.Start
// (Native, Public, BlueprintCallable)

void UScenarioLittleGameBase::Start()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioLittleGameBase", "Start");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioLittleGameBase.Update
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScenarioLittleGameBase::Update(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioLittleGameBase", "Update");

	Params::ScenarioLittleGameBase_Update Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioLittleGameBase.GetInteractionInputComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInteractionInputComponent*       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractionInputComponent* UScenarioLittleGameBase::GetInteractionInputComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioLittleGameBase", "GetInteractionInputComponent");

	Params::ScenarioLittleGameBase_GetInteractionInputComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ScenarioLittleGameBase.GetStateNode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UScenarioStateNode_LittleGame*    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UScenarioStateNode_LittleGame* UScenarioLittleGameBase::GetStateNode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioLittleGameBase", "GetStateNode");

	Params::ScenarioLittleGameBase_GetStateNode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ScenarioStandardLittleGame.GameInput
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FLittleGameInputEvent&     InputEvent                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UScenarioStandardLittleGame::GameInput(const struct FLittleGameInputEvent& InputEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStandardLittleGame", "GameInput");

	Params::ScenarioStandardLittleGame_GameInput Parms{};

	Parms.InputEvent = std::move(InputEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStandardLittleGame.MouseClick
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FLittleGameInputEvent&     InputEvent                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UScenarioStandardLittleGame::MouseClick(const struct FLittleGameInputEvent& InputEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStandardLittleGame", "MouseClick");

	Params::ScenarioStandardLittleGame_MouseClick Parms{};

	Parms.InputEvent = std::move(InputEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStandardLittleGame.MousePress
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FLittleGameInputEvent&     InputEvent                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UScenarioStandardLittleGame::MousePress(const struct FLittleGameInputEvent& InputEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStandardLittleGame", "MousePress");

	Params::ScenarioStandardLittleGame_MousePress Parms{};

	Parms.InputEvent = std::move(InputEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStandardLittleGame.MouseRelease
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FLittleGameInputEvent&     InputEvent                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UScenarioStandardLittleGame::MouseRelease(const struct FLittleGameInputEvent& InputEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStandardLittleGame", "MouseRelease");

	Params::ScenarioStandardLittleGame_MouseRelease Parms{};

	Parms.InputEvent = std::move(InputEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStandardLittleGame.OnGameInput
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FLittleGameInputEvent&     InputEvent                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UScenarioStandardLittleGame::OnGameInput(const struct FLittleGameInputEvent& InputEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStandardLittleGame", "OnGameInput");

	Params::ScenarioStandardLittleGame_OnGameInput Parms{};

	Parms.InputEvent = std::move(InputEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStandardLittleGame.OnInitCameraSequenceFinished
// (Event, Public, BlueprintEvent)

void UScenarioStandardLittleGame::OnInitCameraSequenceFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStandardLittleGame", "OnInitCameraSequenceFinished");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharacterInteractionV3.ScenarioStandardLittleGame.OnLookAround
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScenarioStandardLittleGame::OnLookAround(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStandardLittleGame", "OnLookAround");

	Params::ScenarioStandardLittleGame_OnLookAround Parms{};

	Parms.InValue = InValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharacterInteractionV3.ScenarioStandardLittleGame.OnLookUp
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScenarioStandardLittleGame::OnLookUp(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStandardLittleGame", "OnLookUp");

	Params::ScenarioStandardLittleGame_OnLookUp Parms{};

	Parms.InValue = InValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharacterInteractionV3.ScenarioStandardLittleGame.OnMouseClick
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FLittleGameInputEvent&     InputEvent                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UScenarioStandardLittleGame::OnMouseClick(const struct FLittleGameInputEvent& InputEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStandardLittleGame", "OnMouseClick");

	Params::ScenarioStandardLittleGame_OnMouseClick Parms{};

	Parms.InputEvent = std::move(InputEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStandardLittleGame.OnMousePress
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FLittleGameInputEvent&     InputEvent                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UScenarioStandardLittleGame::OnMousePress(const struct FLittleGameInputEvent& InputEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStandardLittleGame", "OnMousePress");

	Params::ScenarioStandardLittleGame_OnMousePress Parms{};

	Parms.InputEvent = std::move(InputEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStandardLittleGame.OnMouseRelease
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FLittleGameInputEvent&     InputEvent                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UScenarioStandardLittleGame::OnMouseRelease(const struct FLittleGameInputEvent& InputEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStandardLittleGame", "OnMouseRelease");

	Params::ScenarioStandardLittleGame_OnMouseRelease Parms{};

	Parms.InputEvent = std::move(InputEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStandardLittleGame.OnMoveForward
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScenarioStandardLittleGame::OnMoveForward(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStandardLittleGame", "OnMoveForward");

	Params::ScenarioStandardLittleGame_OnMoveForward Parms{};

	Parms.InValue = InValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharacterInteractionV3.ScenarioStandardLittleGame.OnMoveRight
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScenarioStandardLittleGame::OnMoveRight(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStandardLittleGame", "OnMoveRight");

	Params::ScenarioStandardLittleGame_OnMoveRight Parms{};

	Parms.InValue = InValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharacterInteractionV3.ScenarioStandardLittleGame.PlayShowElement
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    ElementName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    NextState                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEndLastShowElement                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScenarioStandardLittleGame::PlayShowElement(const class FString& ElementName, const class FString& NextState, bool bEndLastShowElement)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStandardLittleGame", "PlayShowElement");

	Params::ScenarioStandardLittleGame_PlayShowElement Parms{};

	Parms.ElementName = std::move(ElementName);
	Parms.NextState = std::move(NextState);
	Parms.bEndLastShowElement = bEndLastShowElement;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStandardLittleGame.PlayShowElementList
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<class FString>&            InElements                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const class FString&                    NextState                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEndLastShowElement                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScenarioStandardLittleGame::PlayShowElementList(const TArray<class FString>& InElements, const class FString& NextState, bool bEndLastShowElement)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStandardLittleGame", "PlayShowElementList");

	Params::ScenarioStandardLittleGame_PlayShowElementList Parms{};

	Parms.InElements = std::move(InElements);
	Parms.NextState = std::move(NextState);
	Parms.bEndLastShowElement = bEndLastShowElement;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStandardLittleGame.SetUIState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EScenarioLittleGameUIState              NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScenarioStandardLittleGame::SetUIState(EScenarioLittleGameUIState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStandardLittleGame", "SetUIState");

	Params::ScenarioStandardLittleGame_SetUIState Parms{};

	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStandardLittleGame.DisableInput
// (Final, Native, Public, BlueprintCallable, Const)

void UScenarioStandardLittleGame::DisableInput() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStandardLittleGame", "DisableInput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStandardLittleGame.EnableInput
// (Final, Native, Public, BlueprintCallable, Const)

void UScenarioStandardLittleGame::EnableInput() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStandardLittleGame", "EnableInput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStandardLittleGame.GetCustomGameUI
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FSoftClassPath                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FSoftClassPath UScenarioStandardLittleGame::GetCustomGameUI() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStandardLittleGame", "GetCustomGameUI");

	Params::ScenarioStandardLittleGame_GetCustomGameUI Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ScenarioStandardLittleGame.GetMousePos
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UScenarioStandardLittleGame::GetMousePos() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStandardLittleGame", "GetMousePos");

	Params::ScenarioStandardLittleGame_GetMousePos Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ScenarioStandardLittleGame.GetUIState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EScenarioLittleGameUIState              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EScenarioLittleGameUIState UScenarioStandardLittleGame::GetUIState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStandardLittleGame", "GetUIState");

	Params::ScenarioStandardLittleGame_GetUIState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ScenarioStandardLittleGame.IsBlockInput
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UScenarioStandardLittleGame::IsBlockInput() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStandardLittleGame", "IsBlockInput");

	Params::ScenarioStandardLittleGame_IsBlockInput Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ScenarioStandardLittleGame.IsCustomGameUI
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UScenarioStandardLittleGame::IsCustomGameUI() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStandardLittleGame", "IsCustomGameUI");

	Params::ScenarioStandardLittleGame_IsCustomGameUI Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ScenarioStandardLittleGame.ListenForInputAction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ActionName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputEvent                             EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConsume                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       Callback                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UScenarioStandardLittleGame::ListenForInputAction(class FName ActionName, EInputEvent EventType, bool bConsume, TDelegate<void()> Callback) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStandardLittleGame", "ListenForInputAction");

	Params::ScenarioStandardLittleGame_ListenForInputAction Parms{};

	Parms.ActionName = ActionName;
	Parms.EventType = EventType;
	Parms.bConsume = bConsume;
	Parms.Callback = Callback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ScenarioStandardLittleGame.ListenForKeyAction
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// const struct FKey&                      InKey                                                  (ConstParm, Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputEvent                             EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConsume                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       Callback                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void UScenarioStandardLittleGame::ListenForKeyAction(const struct FKey& InKey, EInputEvent EventType, bool bConsume, TDelegate<void()> Callback) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStandardLittleGame", "ListenForKeyAction");

	Params::ScenarioStandardLittleGame_ListenForKeyAction Parms{};

	Parms.InKey = std::move(InKey);
	Parms.EventType = EventType;
	Parms.bConsume = bConsume;
	Parms.Callback = Callback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStandardLittleGame.PlayShowElementByCallback
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// const class FString&                    ElementName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    NextState                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       ShowElementPlayFinish                                  (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bEndLastShowElement                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScenarioStandardLittleGame::PlayShowElementByCallback(const class FString& ElementName, const class FString& NextState, TDelegate<void()> ShowElementPlayFinish, bool bEndLastShowElement) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStandardLittleGame", "PlayShowElementByCallback");

	Params::ScenarioStandardLittleGame_PlayShowElementByCallback Parms{};

	Parms.ElementName = std::move(ElementName);
	Parms.NextState = std::move(NextState);
	Parms.ShowElementPlayFinish = ShowElementPlayFinish;
	Parms.bEndLastShowElement = bEndLastShowElement;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStandardLittleGame.PlayShowElementListByCallback
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// const TArray<class FString>&            InElements                                             (ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// const class FString&                    NextState                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       ShowElementPlayFinish                                  (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bEndLastShowElement                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScenarioStandardLittleGame::PlayShowElementListByCallback(const TArray<class FString>& InElements, const class FString& NextState, TDelegate<void()> ShowElementPlayFinish, bool bEndLastShowElement) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStandardLittleGame", "PlayShowElementListByCallback");

	Params::ScenarioStandardLittleGame_PlayShowElementListByCallback Parms{};

	Parms.InElements = std::move(InElements);
	Parms.NextState = std::move(NextState);
	Parms.ShowElementPlayFinish = ShowElementPlayFinish;
	Parms.bEndLastShowElement = bEndLastShowElement;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStandardLittleGame.SetInputModeGameAndUI
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// EMouseLockMode                          MouseLockMode                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScenarioStandardLittleGame::SetInputModeGameAndUI(EMouseLockMode MouseLockMode) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStandardLittleGame", "SetInputModeGameAndUI");

	Params::ScenarioStandardLittleGame_SetInputModeGameAndUI Parms{};

	Parms.MouseLockMode = MouseLockMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStandardLittleGame.SetInputModeGameOnly
// (Final, Native, Public, BlueprintCallable, Const)

void UScenarioStandardLittleGame::SetInputModeGameOnly() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStandardLittleGame", "SetInputModeGameOnly");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStandardLittleGame.SetInputModeUIOnly
// (Final, Native, Public, BlueprintCallable, Const)

void UScenarioStandardLittleGame::SetInputModeUIOnly() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStandardLittleGame", "SetInputModeUIOnly");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStandardLittleGame.StopAllListenForKeyAction
// (Final, Native, Public, BlueprintCallable, Const)

void UScenarioStandardLittleGame::StopAllListenForKeyAction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStandardLittleGame", "StopAllListenForKeyAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStandardLittleGame.StopAllListeningForHandle
// (Final, Native, Public, BlueprintCallable, Const)

void UScenarioStandardLittleGame::StopAllListeningForHandle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStandardLittleGame", "StopAllListeningForHandle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStandardLittleGame.StopListenForKeyAction
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// const struct FKey&                      InKey                                                  (ConstParm, Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputEvent                             EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScenarioStandardLittleGame::StopListenForKeyAction(const struct FKey& InKey, EInputEvent EventType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStandardLittleGame", "StopListenForKeyAction");

	Params::ScenarioStandardLittleGame_StopListenForKeyAction Parms{};

	Parms.InKey = std::move(InKey);
	Parms.EventType = EventType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStandardLittleGame.StopListeningForHandle
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// int32                                   InHandle                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScenarioStandardLittleGame::StopListeningForHandle(int32 InHandle) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStandardLittleGame", "StopListeningForHandle");

	Params::ScenarioStandardLittleGame_StopListeningForHandle Parms{};

	Parms.InHandle = InHandle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStandardLittleGame.StopListeningForInputAction
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// class FName                             ActionName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputEvent                             EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScenarioStandardLittleGame::StopListeningForInputAction(class FName ActionName, EInputEvent EventType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStandardLittleGame", "StopListeningForInputAction");

	Params::ScenarioStandardLittleGame_StopListeningForInputAction Parms{};

	Parms.ActionName = ActionName;
	Parms.EventType = EventType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.FennyGunFireLittleGame.GetVoiceTipCfg
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InId                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FFennyVoiceTipCfg          ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FFennyVoiceTipCfg UFennyGunFireLittleGame::GetVoiceTipCfg(int32 InId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FennyGunFireLittleGame", "GetVoiceTipCfg");

	Params::FennyGunFireLittleGame_GetVoiceTipCfg Parms{};

	Parms.InId = InId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.FennyGunFireLittleGame.RandomVoice
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UFennyGunFireLittleGame::RandomVoice()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FennyGunFireLittleGame", "RandomVoice");

	Params::FennyGunFireLittleGame_RandomVoice Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionV3DragInterface.EndDrag
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FTransform&                TargetTransform                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// const struct FVector&                   DeltaLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IInteractionV3DragInterface::EndDrag(const struct FTransform& TargetTransform, const struct FVector& DeltaLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("InteractionV3DragInterface", "EndDrag");

	Params::InteractionV3DragInterface_EndDrag Parms{};

	Parms.TargetTransform = std::move(TargetTransform);
	Parms.DeltaLocation = std::move(DeltaLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionV3DragInterface.StartDrag
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FTransform&                TargetTransform                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// const struct FVector&                   DeltaLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IInteractionV3DragInterface::StartDrag(const struct FTransform& TargetTransform, const struct FVector& DeltaLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("InteractionV3DragInterface", "StartDrag");

	Params::InteractionV3DragInterface_StartDrag Parms{};

	Parms.TargetTransform = std::move(TargetTransform);
	Parms.DeltaLocation = std::move(DeltaLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionV3DragInterface.UpdateDrag
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FTransform&                TargetTransform                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// const struct FVector&                   DeltaLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IInteractionV3DragInterface::UpdateDrag(const struct FTransform& TargetTransform, const struct FVector& DeltaLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("InteractionV3DragInterface", "UpdateDrag");

	Params::InteractionV3DragInterface_UpdateDrag Parms{};

	Parms.TargetTransform = std::move(TargetTransform);
	Parms.DeltaLocation = std::move(DeltaLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionArchivementComponentV3.PlayArchivement
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InId                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionArchivementComponentV3::PlayArchivement(int32 InId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionArchivementComponentV3", "PlayArchivement");

	Params::InteractionArchivementComponentV3_PlayArchivement Parms{};

	Parms.InId = InId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionArchivementComponentV3.SetArchievementPlayed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InId                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionArchivementComponentV3::SetArchievementPlayed(int32 InId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionArchivementComponentV3", "SetArchievementPlayed");

	Params::InteractionArchivementComponentV3_SetArchievementPlayed Parms{};

	Parms.InId = InId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionArchivementComponentV3.SetArchivementComplete
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InId                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionArchivementComponentV3::SetArchivementComplete(int32 InId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionArchivementComponentV3", "SetArchivementComplete");

	Params::InteractionArchivementComponentV3_SetArchivementComplete Parms{};

	Parms.InId = InId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionArchivementComponentV3.SetConditionComplete
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InId                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionArchivementComponentV3::SetConditionComplete(int32 InId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionArchivementComponentV3", "SetConditionComplete");

	Params::InteractionArchivementComponentV3_SetConditionComplete Parms{};

	Parms.InId = InId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionArchivementComponentV3.SetConditionCompleteAdnRefresh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InId                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionArchivementComponentV3::SetConditionCompleteAdnRefresh(int32 InId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionArchivementComponentV3", "SetConditionCompleteAdnRefresh");

	Params::InteractionArchivementComponentV3_SetConditionCompleteAdnRefresh Parms{};

	Parms.InId = InId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionArchivementComponentV3.CanPlay
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   InId                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionArchivementComponentV3::CanPlay(int32 InId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionArchivementComponentV3", "CanPlay");

	Params::InteractionArchivementComponentV3_CanPlay Parms{};

	Parms.InId = InId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionArchivementComponentV3.IsArchivementComplete
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   InId                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionArchivementComponentV3::IsArchivementComplete(int32 InId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionArchivementComponentV3", "IsArchivementComplete");

	Params::InteractionArchivementComponentV3_IsArchivementComplete Parms{};

	Parms.InId = InId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionArchivementComponentV3.IsArchivementPlayed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   InId                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionArchivementComponentV3::IsArchivementPlayed(int32 InId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionArchivementComponentV3", "IsArchivementPlayed");

	Params::InteractionArchivementComponentV3_IsArchivementPlayed Parms{};

	Parms.InId = InId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionArchivementComponentV3.IsConditionComplete
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   InId                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionArchivementComponentV3::IsConditionComplete(int32 InId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionArchivementComponentV3", "IsConditionComplete");

	Params::InteractionArchivementComponentV3_IsConditionComplete Parms{};

	Parms.InId = InId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.FennyShowerLittleGame.GetCameraAdditivePitchAndYaw
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float*                                  OutPitch                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OutYaw                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFennyShowerLittleGame::GetCameraAdditivePitchAndYaw(float* OutPitch, float* OutYaw) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FennyShowerLittleGame", "GetCameraAdditivePitchAndYaw");

	Params::FennyShowerLittleGame_GetCameraAdditivePitchAndYaw Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPitch != nullptr)
		*OutPitch = Parms.OutPitch;

	if (OutYaw != nullptr)
		*OutYaw = Parms.OutYaw;
}


// Function CharacterInteractionV3.FennyShowerLittleGame.GetCanActiveCamera
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFennyShowerLittleGame::GetCanActiveCamera() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FennyShowerLittleGame", "GetCanActiveCamera");

	Params::FennyShowerLittleGame_GetCanActiveCamera Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.FennyShowerLittleGame.PlayStandBy
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// const int32                             idx                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFennyShowerLittleGame::PlayStandBy(const int32 idx) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FennyShowerLittleGame", "PlayStandBy");

	Params::FennyShowerLittleGame_PlayStandBy Parms{};

	Parms.idx = idx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.FennyShowerLittleGame.SetCanActiveCamera
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// const bool                              bCan                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFennyShowerLittleGame::SetCanActiveCamera(const bool bCan) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FennyShowerLittleGame", "SetCanActiveCamera");

	Params::FennyShowerLittleGame_SetCanActiveCamera Parms{};

	Parms.bCan = bCan;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.FennyShowerLittleGame.SetStandByInfo
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// const int32                             idx                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFennyShowerLittleGame::SetStandByInfo(const int32 idx) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FennyShowerLittleGame", "SetStandByInfo");

	Params::FennyShowerLittleGame_SetStandByInfo Parms{};

	Parms.idx = idx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionActorV3.BindOperateActEvent
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FString&                    ActorOperateActName                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TDelegate<void(const class FString& ActorOperateActName, float DeltaSeconds, class UActorOperateAct* ActorOperateAct, EInteractionV3OperateEventType EventType)>&Delegate                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AInteractionActorV3::BindOperateActEvent(const class FString& ActorOperateActName, const TDelegate<void(const class FString& ActorOperateActName, float DeltaSeconds, class UActorOperateAct* ActorOperateAct, EInteractionV3OperateEventType EventType)>& Delegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionActorV3", "BindOperateActEvent");

	Params::InteractionActorV3_BindOperateActEvent Parms{};

	Parms.ActorOperateActName = std::move(ActorOperateActName);
	Parms.Delegate = Delegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionActorV3.OnOperateEnd
// (Event, Protected, BlueprintEvent)
// Parameters:
// const class FString&                    ActorOperateActName                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UActorOperateAct*                 ActorOperateAct                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractionActorV3::OnOperateEnd(const class FString& ActorOperateActName, class UActorOperateAct* ActorOperateAct)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionActorV3", "OnOperateEnd");

	Params::InteractionActorV3_OnOperateEnd Parms{};

	Parms.ActorOperateActName = std::move(ActorOperateActName);
	Parms.ActorOperateAct = ActorOperateAct;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharacterInteractionV3.InteractionActorV3.OnOperateStart
// (Event, Protected, BlueprintEvent)
// Parameters:
// const class FString&                    ActorOperateActName                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UActorOperateAct*                 ActorOperateAct                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractionActorV3::OnOperateStart(const class FString& ActorOperateActName, class UActorOperateAct* ActorOperateAct)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionActorV3", "OnOperateStart");

	Params::InteractionActorV3_OnOperateStart Parms{};

	Parms.ActorOperateActName = std::move(ActorOperateActName);
	Parms.ActorOperateAct = ActorOperateAct;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharacterInteractionV3.InteractionActorV3.OnOperateUpdate
// (Event, Protected, BlueprintEvent)
// Parameters:
// const class FString&                    ActorOperateActName                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UActorOperateAct*                 ActorOperateAct                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractionActorV3::OnOperateUpdate(const class FString& ActorOperateActName, float DeltaSeconds, class UActorOperateAct* ActorOperateAct)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionActorV3", "OnOperateUpdate");

	Params::InteractionActorV3_OnOperateUpdate Parms{};

	Parms.ActorOperateActName = std::move(ActorOperateActName);
	Parms.DeltaSeconds = DeltaSeconds;
	Parms.ActorOperateAct = ActorOperateAct;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharacterInteractionV3.InteractionActorV3.PlayWeightedVoice
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FInteractionVoiceConfig&   Config                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AInteractionActorV3::PlayWeightedVoice(const struct FInteractionVoiceConfig& Config)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionActorV3", "PlayWeightedVoice");

	Params::InteractionActorV3_PlayWeightedVoice Parms{};

	Parms.Config = std::move(Config);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionActorV3.PlayWeightedVoiceWithAnimInstance
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UAnimInstance*                    AnimInstance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FInteractionVoiceConfig&   Config                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AInteractionActorV3::PlayWeightedVoiceWithAnimInstance(class UAnimInstance* AnimInstance, const struct FInteractionVoiceConfig& Config)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionActorV3", "PlayWeightedVoiceWithAnimInstance");

	Params::InteractionActorV3_PlayWeightedVoiceWithAnimInstance Parms{};

	Parms.AnimInstance = AnimInstance;
	Parms.Config = std::move(Config);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionActorV3.ReInitPhysics
// (Native, Public, BlueprintCallable)

void AInteractionActorV3::ReInitPhysics()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionActorV3", "ReInitPhysics");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionActorV3.ResetActor
// (Native, Public, BlueprintCallable)

void AInteractionActorV3::ResetActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionActorV3", "ResetActor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionActorV3.ResetActorPhysics
// (Native, Public, BlueprintCallable)

void AInteractionActorV3::ResetActorPhysics()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionActorV3", "ResetActorPhysics");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionActorV3.StopVoice
// (Native, Public, BlueprintCallable)
// Parameters:
// int32                                   TransitionMS                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInvokeCallback                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractionActorV3::StopVoice(int32 TransitionMS, bool bInvokeCallback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionActorV3", "StopVoice");

	Params::InteractionActorV3_StopVoice Parms{};

	Parms.TransitionMS = TransitionMS;
	Parms.bInvokeCallback = bInvokeCallback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionActorV3.UnbindOperateActEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    ActorOperateActName                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractionActorV3::UnbindOperateActEvent(const class FString& ActorOperateActName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionActorV3", "UnbindOperateActEvent");

	Params::InteractionActorV3_UnbindOperateActEvent Parms{};

	Parms.ActorOperateActName = std::move(ActorOperateActName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionCameraActor.GetCameraActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AInteractionCameraActor*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AInteractionCameraActor* AInteractionCameraActor::GetCameraActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InteractionCameraActor", "GetCameraActor");

	Params::InteractionCameraActor_GetCameraActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionCameraActor.ActiveCamera
// (Final, Native, Public, BlueprintCallable)

void AInteractionCameraActor::ActiveCamera()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionCameraActor", "ActiveCamera");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionCameraActor.GetAdditivePitchAndYaw
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// float*                                  OutPitch                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OutYaw                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractionCameraActor::GetAdditivePitchAndYaw(float* OutPitch, float* OutYaw)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionCameraActor", "GetAdditivePitchAndYaw");

	Params::InteractionCameraActor_GetAdditivePitchAndYaw Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPitch != nullptr)
		*OutPitch = Parms.OutPitch;

	if (OutYaw != nullptr)
		*OutYaw = Parms.OutYaw;
}


// Function CharacterInteractionV3.InteractionCameraActor.SetOperateConfig
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractionCameraActor::SetOperateConfig(class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionCameraActor", "SetOperateConfig");

	Params::InteractionCameraActor_SetOperateConfig Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionCameraActor.SetStandbyConfig
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractionCameraActor::SetStandbyConfig(class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionCameraActor", "SetStandbyConfig");

	Params::InteractionCameraActor_SetStandbyConfig Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionCameraActor.ToggleDebugCameraModifierInfo
// (Final, Native, Public, BlueprintCallable)

void AInteractionCameraActor::ToggleDebugCameraModifierInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionCameraActor", "ToggleDebugCameraModifierInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionCameraActor.GetDefaultViewInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FMinimalViewInfo           ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FMinimalViewInfo AInteractionCameraActor::GetDefaultViewInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionCameraActor", "GetDefaultViewInfo");

	Params::InteractionCameraActor_GetDefaultViewInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionCameraInstance.AddInput
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector2D&                 Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionCameraInstance::AddInput(const struct FVector2D& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionCameraInstance", "AddInput");

	Params::InteractionCameraInstance_AddInput Parms{};

	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionCameraInstance.SetOperateConfig
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionCameraInstance::SetOperateConfig(class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionCameraInstance", "SetOperateConfig");

	Params::InteractionCameraInstance_SetOperateConfig Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionCameraInstance.SetStandbyConfig
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionCameraInstance::SetStandbyConfig(class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionCameraInstance", "SetStandbyConfig");

	Params::InteractionCameraInstance_SetStandbyConfig Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionSkeletalActorV3.GetInteractionCharacterAnimInstance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInteractionV3CharacterAnimInstance*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractionV3CharacterAnimInstance* AInteractionSkeletalActorV3::GetInteractionCharacterAnimInstance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionSkeletalActorV3", "GetInteractionCharacterAnimInstance");

	Params::InteractionSkeletalActorV3_GetInteractionCharacterAnimInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionCharacterV3.InteractionStartBlush
// (Event, Public, BlueprintEvent)

void AInteractionCharacterV3::InteractionStartBlush()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionCharacterV3", "InteractionStartBlush");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharacterInteractionV3.InteractionCharacterV3.InteractionStopBlush
// (Event, Public, BlueprintEvent)

void AInteractionCharacterV3::InteractionStopBlush()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionCharacterV3", "InteractionStopBlush");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharacterInteractionV3.InteractionCharacterV3.OnLipSyncDataReady
// (Final, Native, Public)

void AInteractionCharacterV3::OnLipSyncDataReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionCharacterV3", "OnLipSyncDataReady");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionCharacterV3.SetKawaiiBlendScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   KawaiiBlendScaleValue                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractionCharacterV3::SetKawaiiBlendScale(float KawaiiBlendScaleValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionCharacterV3", "SetKawaiiBlendScale");

	Params::InteractionCharacterV3_SetKawaiiBlendScale Parms{};

	Parms.KawaiiBlendScaleValue = KawaiiBlendScaleValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionCharacterV3.StartKawaiiBlend
// (Final, Native, Public, BlueprintCallable)

void AInteractionCharacterV3::StartKawaiiBlend()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionCharacterV3", "StartKawaiiBlend");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionCharacterV3.GetInteractionCharacterFaceAnimInstance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInteractionV3FaceAnimInstance*   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractionV3FaceAnimInstance* AInteractionCharacterV3::GetInteractionCharacterFaceAnimInstance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionCharacterV3", "GetInteractionCharacterFaceAnimInstance");

	Params::InteractionCharacterV3_GetInteractionCharacterFaceAnimInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionCharacterV3.GetKawaiiAlphaValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AInteractionCharacterV3::GetKawaiiAlphaValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionCharacterV3", "GetKawaiiAlphaValue");

	Params::InteractionCharacterV3_GetKawaiiAlphaValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionV3InputCollision.IsInCollision
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintEvent, Const)
// Parameters:
// const struct FVector2D&                 CheckPos                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionV3InputCollision::IsInCollision(const struct FVector2D& CheckPos) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionV3InputCollision", "IsInCollision");

	Params::InteractionV3InputCollision_IsInCollision Parms{};

	Parms.CheckPos = std::move(CheckPos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionDirectorV3.GetInstance
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AInteractionDirectorV3*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AInteractionDirectorV3* AInteractionDirectorV3::GetInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InteractionDirectorV3", "GetInstance");

	Params::InteractionDirectorV3_GetInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionDirectorV3.GetInteractionDirector
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AInteractionDirectorV3*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AInteractionDirectorV3* AInteractionDirectorV3::GetInteractionDirector(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InteractionDirectorV3", "GetInteractionDirector");

	Params::InteractionDirectorV3_GetInteractionDirector Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionDirectorV3.ClearPerformers
// (Final, Native, Public, BlueprintCallable)

void AInteractionDirectorV3::ClearPerformers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDirectorV3", "ClearPerformers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionDirectorV3.CreateInteractionActorFromName
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      ActorName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AInteractionActorV3*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AInteractionActorV3* AInteractionDirectorV3::CreateInteractionActorFromName(const class FName& ActorName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDirectorV3", "CreateInteractionActorFromName");

	Params::InteractionDirectorV3_CreateInteractionActorFromName Parms{};

	Parms.ActorName = ActorName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionDirectorV3.CreateInteractionActorInScenario
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      ScenarioName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractionDirectorV3::CreateInteractionActorInScenario(const class FName& ScenarioName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDirectorV3", "CreateInteractionActorInScenario");

	Params::InteractionDirectorV3_CreateInteractionActorInScenario Parms{};

	Parms.ScenarioName = ScenarioName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionDirectorV3.EndScenarioShowElement
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      ShowElementName                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractionDirectorV3::EndScenarioShowElement(const class FName& ShowElementName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDirectorV3", "EndScenarioShowElement");

	Params::InteractionDirectorV3_EndScenarioShowElement Parms{};

	Parms.ShowElementName = ShowElementName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionDirectorV3.EnterScenario
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    ScenarioName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AInteractionDirectorV3::EnterScenario(const class FString& ScenarioName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDirectorV3", "EnterScenario");

	Params::InteractionDirectorV3_EnterScenario Parms{};

	Parms.ScenarioName = std::move(ScenarioName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionDirectorV3.OnEnterScenario
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// const class FString&                    ScenarioName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractionDirectorV3::OnEnterScenario(const class FString& ScenarioName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDirectorV3", "OnEnterScenario");

	Params::InteractionDirectorV3_OnEnterScenario Parms{};

	Parms.ScenarioName = std::move(ScenarioName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionDirectorV3.PlayScenarioShowElement
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      ShowElementName                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FShowElementsAnim>        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FShowElementsAnim> AInteractionDirectorV3::PlayScenarioShowElement(const class FName& ShowElementName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDirectorV3", "PlayScenarioShowElement");

	Params::InteractionDirectorV3_PlayScenarioShowElement Parms{};

	Parms.ShowElementName = ShowElementName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionDirectorV3.QuitScenarioShowElement
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      ShowElementName                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractionDirectorV3::QuitScenarioShowElement(const class FName& ShowElementName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDirectorV3", "QuitScenarioShowElement");

	Params::InteractionDirectorV3_QuitScenarioShowElement Parms{};

	Parms.ShowElementName = ShowElementName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionDirectorV3.RemoveInteractionActor
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      Name_0                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractionDirectorV3::RemoveInteractionActor(const class FName& Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDirectorV3", "RemoveInteractionActor");

	Params::InteractionDirectorV3_RemoveInteractionActor Parms{};

	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionDirectorV3.RemoveInteractionActorInScenario
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      ScenarioName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractionDirectorV3::RemoveInteractionActorInScenario(const class FName& ScenarioName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDirectorV3", "RemoveInteractionActorInScenario");

	Params::InteractionDirectorV3_RemoveInteractionActorInScenario Parms{};

	Parms.ScenarioName = ScenarioName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionDirectorV3.ResetActors
// (Final, Native, Public, BlueprintCallable)

void AInteractionDirectorV3::ResetActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDirectorV3", "ResetActors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionDirectorV3.ShowActorsComponents
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    ScName                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bReset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractionDirectorV3::ShowActorsComponents(const class FString& ScName, bool bReset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDirectorV3", "ShowActorsComponents");

	Params::InteractionDirectorV3_ShowActorsComponents Parms{};

	Parms.ScName = std::move(ScName);
	Parms.bReset = bReset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionDirectorV3.ToggleDebugOperateCollision
// (Final, Native, Public, BlueprintCallable)

void AInteractionDirectorV3::ToggleDebugOperateCollision()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDirectorV3", "ToggleDebugOperateCollision");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionDirectorV3.GetActiveStateNode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UScenarioStateNode*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UScenarioStateNode* AInteractionDirectorV3::GetActiveStateNode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDirectorV3", "GetActiveStateNode");

	Params::InteractionDirectorV3_GetActiveStateNode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionDirectorV3.GetAllInteractionActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class AInteractionActorV3*>      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AInteractionActorV3*> AInteractionDirectorV3::GetAllInteractionActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDirectorV3", "GetAllInteractionActor");

	Params::InteractionDirectorV3_GetAllInteractionActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionDirectorV3.GetArchivementComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInteractionArchivementComponentV3*ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractionArchivementComponentV3* AInteractionDirectorV3::GetArchivementComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDirectorV3", "GetArchivementComponent");

	Params::InteractionDirectorV3_GetArchivementComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionDirectorV3.GetDeltaPressedMousePosition
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D AInteractionDirectorV3::GetDeltaPressedMousePosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDirectorV3", "GetDeltaPressedMousePosition");

	Params::InteractionDirectorV3_GetDeltaPressedMousePosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionDirectorV3.GetHolyLightComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UHolyLightV3Component*            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UHolyLightV3Component* AInteractionDirectorV3::GetHolyLightComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDirectorV3", "GetHolyLightComponent");

	Params::InteractionDirectorV3_GetHolyLightComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionDirectorV3.GetInteractionActor
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName&                      ActorName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AInteractionActorV3*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AInteractionActorV3* AInteractionDirectorV3::GetInteractionActor(const class FName& ActorName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDirectorV3", "GetInteractionActor");

	Params::InteractionDirectorV3_GetInteractionActor Parms{};

	Parms.ActorName = ActorName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionDirectorV3.GetMouseDownPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D AInteractionDirectorV3::GetMouseDownPosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDirectorV3", "GetMouseDownPosition");

	Params::InteractionDirectorV3_GetMouseDownPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionDirectorV3.GetMousePosition
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D AInteractionDirectorV3::GetMousePosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDirectorV3", "GetMousePosition");

	Params::InteractionDirectorV3_GetMousePosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionDirectorV3.GetNonOperateDeltaPressedMousePosition
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D AInteractionDirectorV3::GetNonOperateDeltaPressedMousePosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDirectorV3", "GetNonOperateDeltaPressedMousePosition");

	Params::InteractionDirectorV3_GetNonOperateDeltaPressedMousePosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionDirectorV3.GetScenarioShowElementDurationTime
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName&                      ShowElementName                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AInteractionDirectorV3::GetScenarioShowElementDurationTime(const class FName& ShowElementName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDirectorV3", "GetScenarioShowElementDurationTime");

	Params::InteractionDirectorV3_GetScenarioShowElementDurationTime Parms{};

	Parms.ShowElementName = ShowElementName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionDirectorV3.GetSelectedCollision
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInteractionV3InputCollision*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractionV3InputCollision* AInteractionDirectorV3::GetSelectedCollision() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDirectorV3", "GetSelectedCollision");

	Params::InteractionDirectorV3_GetSelectedCollision Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionDirectorV3.IsMouseInScreen
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AInteractionDirectorV3::IsMouseInScreen() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDirectorV3", "IsMouseInScreen");

	Params::InteractionDirectorV3_IsMouseInScreen Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionDirectorV3.IsMousePressed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AInteractionDirectorV3::IsMousePressed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDirectorV3", "IsMousePressed");

	Params::InteractionDirectorV3_IsMousePressed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionDirectorV3.TransitionState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FString&                    InScenarioStateName                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AInteractionDirectorV3::TransitionState(const class FString& InScenarioStateName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDirectorV3", "TransitionState");

	Params::InteractionDirectorV3_TransitionState Parms{};

	Parms.InScenarioStateName = std::move(InScenarioStateName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionFPSCameraActor.GetInteractorFPSCameraActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AInteractionFPSCameraActor*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AInteractionFPSCameraActor* AInteractionFPSCameraActor::GetInteractorFPSCameraActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InteractionFPSCameraActor", "GetInteractorFPSCameraActor");

	Params::InteractionFPSCameraActor_GetInteractorFPSCameraActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionFPSCameraActor.IsActiveFPSModel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AInteractionFPSCameraActor::IsActiveFPSModel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InteractionFPSCameraActor", "IsActiveFPSModel");

	Params::InteractionFPSCameraActor_IsActiveFPSModel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionFPSCameraActor.ActiveCamera
// (Final, Native, Public, BlueprintCallable)

void AInteractionFPSCameraActor::ActiveCamera()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionFPSCameraActor", "ActiveCamera");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionFPSCameraActor.DisableCamera
// (Final, Native, Public, BlueprintCallable)

void AInteractionFPSCameraActor::DisableCamera()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionFPSCameraActor", "DisableCamera");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionFPSCameraActor.AddInput
// (Final, Native, Public, HasDefaults, BlueprintCallable, Const)
// Parameters:
// const struct FVector2D&                 InValue                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractionFPSCameraActor::AddInput(const struct FVector2D& InValue) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionFPSCameraActor", "AddInput");

	Params::InteractionFPSCameraActor_AddInput Parms{};

	Parms.InValue = std::move(InValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionFPSCameraActor.IsActiveCamera
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AInteractionFPSCameraActor::IsActiveCamera() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionFPSCameraActor", "IsActiveCamera");

	Params::InteractionFPSCameraActor_IsActiveCamera Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionFPSCameraInstance.AddInput
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector2D&                 Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionFPSCameraInstance::AddInput(const struct FVector2D& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionFPSCameraInstance", "AddInput");

	Params::InteractionFPSCameraInstance_AddInput Parms{};

	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionFPSCameraInstance.ResetData
// (Final, Native, Public, BlueprintCallable)

void UInteractionFPSCameraInstance::ResetData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionFPSCameraInstance", "ResetData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionInputComponent.AddBlockInteractionOperate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    InReason                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionInputComponent::AddBlockInteractionOperate(const class FString& InReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionInputComponent", "AddBlockInteractionOperate");

	Params::InteractionInputComponent_AddBlockInteractionOperate Parms{};

	Parms.InReason = std::move(InReason);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionInputComponent.AddMouseButtonEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bDown                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       InAction                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UInteractionInputComponent::AddMouseButtonEvent(bool bDown, TDelegate<void()> InAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionInputComponent", "AddMouseButtonEvent");

	Params::InteractionInputComponent_AddMouseButtonEvent Parms{};

	Parms.bDown = bDown;
	Parms.InAction = InAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionInputComponent.HandleMouseButtonEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bDown                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionInputComponent::HandleMouseButtonEvent(bool bDown)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionInputComponent", "HandleMouseButtonEvent");

	Params::InteractionInputComponent_HandleMouseButtonEvent Parms{};

	Parms.bDown = bDown;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionInputComponent.ListenForInputAction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ActionName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputEvent                             EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConsume                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       Callback                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UInteractionInputComponent::ListenForInputAction(class FName ActionName, EInputEvent EventType, bool bConsume, TDelegate<void()> Callback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionInputComponent", "ListenForInputAction");

	Params::InteractionInputComponent_ListenForInputAction Parms{};

	Parms.ActionName = ActionName;
	Parms.EventType = EventType;
	Parms.bConsume = bConsume;
	Parms.Callback = Callback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionInputComponent.ListenForKeyAction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FKey&                      InKey                                                  (ConstParm, Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputEvent                             EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConsume                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       Callback                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void UInteractionInputComponent::ListenForKeyAction(const struct FKey& InKey, EInputEvent EventType, bool bConsume, TDelegate<void()> Callback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionInputComponent", "ListenForKeyAction");

	Params::InteractionInputComponent_ListenForKeyAction Parms{};

	Parms.InKey = std::move(InKey);
	Parms.EventType = EventType;
	Parms.bConsume = bConsume;
	Parms.Callback = Callback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionInputComponent.LookAround
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionInputComponent::LookAround(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionInputComponent", "LookAround");

	Params::InteractionInputComponent_LookAround Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionInputComponent.LookUp
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionInputComponent::LookUp(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionInputComponent", "LookUp");

	Params::InteractionInputComponent_LookUp Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionInputComponent.MoveForward
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionInputComponent::MoveForward(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionInputComponent", "MoveForward");

	Params::InteractionInputComponent_MoveForward Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionInputComponent.MoveRight
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionInputComponent::MoveRight(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionInputComponent", "MoveRight");

	Params::InteractionInputComponent_MoveRight Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionInputComponent.RemoveAllBlockInteractionOperate
// (Final, Native, Public, BlueprintCallable)

void UInteractionInputComponent::RemoveAllBlockInteractionOperate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionInputComponent", "RemoveAllBlockInteractionOperate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionInputComponent.RemoveAllMouseButtonEvent
// (Final, Native, Public, BlueprintCallable)

void UInteractionInputComponent::RemoveAllMouseButtonEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionInputComponent", "RemoveAllMouseButtonEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionInputComponent.RemoveBlockInteractionOperate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    InReason                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionInputComponent::RemoveBlockInteractionOperate(const class FString& InReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionInputComponent", "RemoveBlockInteractionOperate");

	Params::InteractionInputComponent_RemoveBlockInteractionOperate Parms{};

	Parms.InReason = std::move(InReason);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionInputComponent.RemoveMouseButtonEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InHandle                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionInputComponent::RemoveMouseButtonEvent(int32 InHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionInputComponent", "RemoveMouseButtonEvent");

	Params::InteractionInputComponent_RemoveMouseButtonEvent Parms{};

	Parms.InHandle = InHandle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionInputComponent.SetIsMouseInScreen
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              bInScreen                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionInputComponent::SetIsMouseInScreen(const bool bInScreen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionInputComponent", "SetIsMouseInScreen");

	Params::InteractionInputComponent_SetIsMouseInScreen Parms{};

	Parms.bInScreen = bInScreen;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionInputComponent.SetIsMousePressed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              bDown                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionInputComponent::SetIsMousePressed(const bool bDown)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionInputComponent", "SetIsMousePressed");

	Params::InteractionInputComponent_SetIsMousePressed Parms{};

	Parms.bDown = bDown;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionInputComponent.SetMouseDownPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector2D&                 Pos                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionInputComponent::SetMouseDownPosition(const struct FVector2D& Pos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionInputComponent", "SetMouseDownPosition");

	Params::InteractionInputComponent_SetMouseDownPosition Parms{};

	Parms.Pos = std::move(Pos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionInputComponent.SetMousePosition
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector2D&                 Pos                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionInputComponent::SetMousePosition(const struct FVector2D& Pos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionInputComponent", "SetMousePosition");

	Params::InteractionInputComponent_SetMousePosition Parms{};

	Parms.Pos = std::move(Pos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionInputComponent.AddActionMapping
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FInteractionActionKeyMapping&InActionKeyMapping                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const bool                              bAdd                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionInputComponent::AddActionMapping(const struct FInteractionActionKeyMapping& InActionKeyMapping, const bool bAdd) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionInputComponent", "AddActionMapping");

	Params::InteractionInputComponent_AddActionMapping Parms{};

	Parms.InActionKeyMapping = std::move(InActionKeyMapping);
	Parms.bAdd = bAdd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionInputComponent.GetActiveStateNode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UScenarioStateNode*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UScenarioStateNode* UInteractionInputComponent::GetActiveStateNode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionInputComponent", "GetActiveStateNode");

	Params::InteractionInputComponent_GetActiveStateNode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionInputComponent.GetMouseDownPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UInteractionInputComponent::GetMouseDownPosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionInputComponent", "GetMouseDownPosition");

	Params::InteractionInputComponent_GetMouseDownPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionInputComponent.GetMousePosition
// (Native, Event, Public, HasDefaults, BlueprintEvent, Const)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UInteractionInputComponent::GetMousePosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionInputComponent", "GetMousePosition");

	Params::InteractionInputComponent_GetMousePosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionInputComponent.GetNonOperatePressedMouseMove
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UInteractionInputComponent::GetNonOperatePressedMouseMove() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionInputComponent", "GetNonOperatePressedMouseMove");

	Params::InteractionInputComponent_GetNonOperatePressedMouseMove Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionInputComponent.GetPressedMouseMove
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UInteractionInputComponent::GetPressedMouseMove() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionInputComponent", "GetPressedMouseMove");

	Params::InteractionInputComponent_GetPressedMouseMove Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionInputComponent.HasBlockInteractionOperate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FString&                    InReason                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionInputComponent::HasBlockInteractionOperate(const class FString& InReason) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionInputComponent", "HasBlockInteractionOperate");

	Params::InteractionInputComponent_HasBlockInteractionOperate Parms{};

	Parms.InReason = std::move(InReason);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionInputComponent.IsBlockInteractionOperate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionInputComponent::IsBlockInteractionOperate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionInputComponent", "IsBlockInteractionOperate");

	Params::InteractionInputComponent_IsBlockInteractionOperate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionInputComponent.IsListeningForInputAction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ActionName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionInputComponent::IsListeningForInputAction(class FName ActionName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionInputComponent", "IsListeningForInputAction");

	Params::InteractionInputComponent_IsListeningForInputAction Parms{};

	Parms.ActionName = ActionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionInputComponent.IsMouseInScreen
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionInputComponent::IsMouseInScreen() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionInputComponent", "IsMouseInScreen");

	Params::InteractionInputComponent_IsMouseInScreen Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionInputComponent.IsMousePressed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionInputComponent::IsMousePressed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionInputComponent", "IsMousePressed");

	Params::InteractionInputComponent_IsMousePressed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionInputComponent.RegisterInputComponent
// (Final, Native, Public, BlueprintCallable, Const)

void UInteractionInputComponent::RegisterInputComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionInputComponent", "RegisterInputComponent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionInputComponent.StopListenForKeyAction
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// const struct FKey&                      InKey                                                  (ConstParm, Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputEvent                             EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionInputComponent::StopListenForKeyAction(const struct FKey& InKey, EInputEvent EventType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionInputComponent", "StopListenForKeyAction");

	Params::InteractionInputComponent_StopListenForKeyAction Parms{};

	Parms.InKey = std::move(InKey);
	Parms.EventType = EventType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionInputComponent.StopListeningForHandle
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// int32                                   InHandle                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionInputComponent::StopListeningForHandle(int32 InHandle) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionInputComponent", "StopListeningForHandle");

	Params::InteractionInputComponent_StopListeningForHandle Parms{};

	Parms.InHandle = InHandle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionInputComponent.StopListeningForInputAction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ActionName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputEvent                             EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UInteractionInputComponent::StopListeningForInputAction(class FName ActionName, EInputEvent EventType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionInputComponent", "StopListeningForInputAction");

	Params::InteractionInputComponent_StopListeningForInputAction Parms{};

	Parms.ActionName = ActionName;
	Parms.EventType = EventType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionInputComponent.UnregisterInputComponent
// (Final, Native, Public, BlueprintCallable, Const)

void UInteractionInputComponent::UnregisterInputComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionInputComponent", "UnregisterInputComponent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionV3InputControl.GetBlendOutAlpha
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInteractionV3InputControl::GetBlendOutAlpha() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionV3InputControl", "GetBlendOutAlpha");

	Params::InteractionV3InputControl_GetBlendOutAlpha Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionV3InputControl.GetDragOffset
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UInteractionV3InputControl::GetDragOffset() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionV3InputControl", "GetDragOffset");

	Params::InteractionV3InputControl_GetDragOffset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionV3InputControl.GetDragValue
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UInteractionV3InputControl::GetDragValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionV3InputControl", "GetDragValue");

	Params::InteractionV3InputControl_GetDragValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionV3InputControl.GetInputFloatValue
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInteractionV3InputControl::GetInputFloatValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionV3InputControl", "GetInputFloatValue");

	Params::InteractionV3InputControl_GetInputFloatValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionV3InputControl.GetInputValue
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UInteractionV3InputControl::GetInputValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionV3InputControl", "GetInputValue");

	Params::InteractionV3InputControl_GetInputValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionPlayV3.GetScenarioStateMachine
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    InScenarioName                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UScenarioStateMachine*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UScenarioStateMachine* AInteractionPlayV3::GetScenarioStateMachine(const class FString& InScenarioName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionPlayV3", "GetScenarioStateMachine");

	Params::InteractionPlayV3_GetScenarioStateMachine Parms{};

	Parms.InScenarioName = std::move(InScenarioName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionPlayV3.GetSceneActorHideComConfig
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* AInteractionPlayV3::GetSceneActorHideComConfig()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionPlayV3", "GetSceneActorHideComConfig");

	Params::InteractionPlayV3_GetSceneActorHideComConfig Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionPlayV3.Start
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    InScenarioName                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AInteractionPlayV3::Start(const class FString& InScenarioName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionPlayV3", "Start");

	Params::InteractionPlayV3_Start Parms{};

	Parms.InScenarioName = std::move(InScenarioName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionPlayV3.Clear
// (Final, Native, Public, BlueprintCallable, Const)

void AInteractionPlayV3::Clear() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionPlayV3", "Clear");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionPlayV3.GetActorStaticInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName&                      ActorName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FInteractionActorStaticInfo*     OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AInteractionPlayV3::GetActorStaticInfo(const class FName& ActorName, struct FInteractionActorStaticInfo* OutInfo) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionPlayV3", "GetActorStaticInfo");

	Params::InteractionPlayV3_GetActorStaticInfo Parms{};

	Parms.ActorName = ActorName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionPlayV3.GetCharacterActors
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class AInteractionCharacterV3*>* OutCharacters                                          (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void AInteractionPlayV3::GetCharacterActors(TArray<class AInteractionCharacterV3*>* OutCharacters) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionPlayV3", "GetCharacterActors");

	Params::InteractionPlayV3_GetCharacterActors Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutCharacters != nullptr)
		*OutCharacters = std::move(Parms.OutCharacters);
}


// Function CharacterInteractionV3.InteractionPlayV3.GetInteractionDirector
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AInteractionDirectorV3*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AInteractionDirectorV3* AInteractionPlayV3::GetInteractionDirector() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionPlayV3", "GetInteractionDirector");

	Params::InteractionPlayV3_GetInteractionDirector Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionPlayV3.GetScenarioActors
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName&                      ScenarioName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSet<class FName>*                      OutNames                                               (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AInteractionPlayV3::GetScenarioActors(const class FName& ScenarioName, TSet<class FName>* OutNames) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionPlayV3", "GetScenarioActors");

	Params::InteractionPlayV3_GetScenarioActors Parms{};

	Parms.ScenarioName = ScenarioName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutNames != nullptr)
		*OutNames = std::move(Parms.OutNames);

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionPlayV3.GetScenarioShowElementStaticInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName&                      ShowElementName                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FInteractionScenarioShowElementStaticInfo*OutInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AInteractionPlayV3::GetScenarioShowElementStaticInfo(const class FName& ShowElementName, struct FInteractionScenarioShowElementStaticInfo* OutInfo) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionPlayV3", "GetScenarioShowElementStaticInfo");

	Params::InteractionPlayV3_GetScenarioShowElementStaticInfo Parms{};

	Parms.ShowElementName = ShowElementName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionPlayV3.GetStateStandByActors
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName&                      ScenaioName                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      StateName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSet<class FName>*                      ActorNames                                             (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AInteractionPlayV3::GetStateStandByActors(const class FName& ScenaioName, const class FName& StateName, TSet<class FName>* ActorNames) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionPlayV3", "GetStateStandByActors");

	Params::InteractionPlayV3_GetStateStandByActors Parms{};

	Parms.ScenaioName = ScenaioName;
	Parms.StateName = StateName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ActorNames != nullptr)
		*ActorNames = std::move(Parms.ActorNames);

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionV3CharacterAnimInstance.PlayConfessionAnim
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimSequence*                    InConfessionAnim                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InBlendInTime                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InBlendOutTime                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionV3CharacterAnimInstance::PlayConfessionAnim(class UAnimSequence* InConfessionAnim, float InBlendInTime, float InBlendOutTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionV3CharacterAnimInstance", "PlayConfessionAnim");

	Params::InteractionV3CharacterAnimInstance_PlayConfessionAnim Parms{};

	Parms.InConfessionAnim = InConfessionAnim;
	Parms.InBlendInTime = InBlendInTime;
	Parms.InBlendOutTime = InBlendOutTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionV3CharacterAnimInstance.PlayLastFrameAnim
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimSequence*                    InLastFrameAnim                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequence*                    InBreathAdditiveAnim                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionV3CharacterAnimInstance::PlayLastFrameAnim(class UAnimSequence* InLastFrameAnim, class UAnimSequence* InBreathAdditiveAnim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionV3CharacterAnimInstance", "PlayLastFrameAnim");

	Params::InteractionV3CharacterAnimInstance_PlayLastFrameAnim Parms{};

	Parms.InLastFrameAnim = InLastFrameAnim;
	Parms.InBreathAdditiveAnim = InBreathAdditiveAnim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionV3CharacterAnimInstance.ResetSeqPlayerPos
// (Final, Native, Public, BlueprintCallable)

void UInteractionV3CharacterAnimInstance::ResetSeqPlayerPos()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionV3CharacterAnimInstance", "ResetSeqPlayerPos");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionV3CharacterAnimInstance.SetEyesFollowHeadRot
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector2D&                 InEyesFollowHeadRot                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionV3CharacterAnimInstance::SetEyesFollowHeadRot(const struct FVector2D& InEyesFollowHeadRot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionV3CharacterAnimInstance", "SetEyesFollowHeadRot");

	Params::InteractionV3CharacterAnimInstance_SetEyesFollowHeadRot Parms{};

	Parms.InEyesFollowHeadRot = std::move(InEyesFollowHeadRot);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionV3CharacterAnimInstance.SetIdleAnim
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimSequence*                    InAnimSequence                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionV3CharacterAnimInstance::SetIdleAnim(class UAnimSequence* InAnimSequence)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionV3CharacterAnimInstance", "SetIdleAnim");

	Params::InteractionV3CharacterAnimInstance_SetIdleAnim Parms{};

	Parms.InAnimSequence = InAnimSequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionV3CharacterAnimInstance.SetIdleAnimState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionV3CharacterAnimInstance::SetIdleAnimState(bool bNewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionV3CharacterAnimInstance", "SetIdleAnimState");

	Params::InteractionV3CharacterAnimInstance_SetIdleAnimState Parms{};

	Parms.bNewState = bNewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionV3CharacterAnimInstance.StopConfessionAnim
// (Final, Native, Public, BlueprintCallable)

void UInteractionV3CharacterAnimInstance::StopConfessionAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionV3CharacterAnimInstance", "StopConfessionAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionV3CharacterAnimInstance.StopLastFrameAdditiveAnim
// (Final, Native, Public, BlueprintCallable)

void UInteractionV3CharacterAnimInstance::StopLastFrameAdditiveAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionV3CharacterAnimInstance", "StopLastFrameAdditiveAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionV3CharacterAnimInstance.StopLastFrameAnim
// (Final, Native, Public, BlueprintCallable)

void UInteractionV3CharacterAnimInstance::StopLastFrameAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionV3CharacterAnimInstance", "StopLastFrameAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionV3Event_Achievement.GetArchivementComponentV3
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInteractionArchivementComponentV3*ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractionArchivementComponentV3* UInteractionV3Event_Achievement::GetArchivementComponentV3() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionV3Event_Achievement", "GetArchivementComponentV3");

	Params::InteractionV3Event_Achievement_GetArchivementComponentV3 Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionV3FaceAnimInstance.GetEyeBlend
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UBlendSpace*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBlendSpace* UInteractionV3FaceAnimInstance::GetEyeBlend()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionV3FaceAnimInstance", "GetEyeBlend");

	Params::InteractionV3FaceAnimInstance_GetEyeBlend Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionV3FaceAnimInstance.PlayConfessionAnim
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimSequence*                    InConfessionAnim                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InBlendInTime                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InBlendOutTime                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionV3FaceAnimInstance::PlayConfessionAnim(class UAnimSequence* InConfessionAnim, float InBlendInTime, float InBlendOutTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionV3FaceAnimInstance", "PlayConfessionAnim");

	Params::InteractionV3FaceAnimInstance_PlayConfessionAnim Parms{};

	Parms.InConfessionAnim = InConfessionAnim;
	Parms.InBlendInTime = InBlendInTime;
	Parms.InBlendOutTime = InBlendOutTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionV3FaceAnimInstance.PlayLastFrameAnim
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimSequence*                    InLastFrameAnim                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionV3FaceAnimInstance::PlayLastFrameAnim(class UAnimSequence* InLastFrameAnim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionV3FaceAnimInstance", "PlayLastFrameAnim");

	Params::InteractionV3FaceAnimInstance_PlayLastFrameAnim Parms{};

	Parms.InLastFrameAnim = InLastFrameAnim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionV3FaceAnimInstance.SetEyeBlend
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UBlendSpace*                      NewBlend                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionV3FaceAnimInstance::SetEyeBlend(class UBlendSpace* NewBlend)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionV3FaceAnimInstance", "SetEyeBlend");

	Params::InteractionV3FaceAnimInstance_SetEyeBlend Parms{};

	Parms.NewBlend = NewBlend;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionV3FaceAnimInstance.SetFaceIdleAnim
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimSequence*                    InAnimSequence                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionV3FaceAnimInstance::SetFaceIdleAnim(class UAnimSequence* InAnimSequence)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionV3FaceAnimInstance", "SetFaceIdleAnim");

	Params::InteractionV3FaceAnimInstance_SetFaceIdleAnim Parms{};

	Parms.InAnimSequence = InAnimSequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionV3FaceAnimInstance.SetMouseFollowEyeOffset
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector2D&                 InMouseFollowEyeOffset                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionV3FaceAnimInstance::SetMouseFollowEyeOffset(const struct FVector2D& InMouseFollowEyeOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionV3FaceAnimInstance", "SetMouseFollowEyeOffset");

	Params::InteractionV3FaceAnimInstance_SetMouseFollowEyeOffset Parms{};

	Parms.InMouseFollowEyeOffset = std::move(InMouseFollowEyeOffset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionV3FaceAnimInstance.StopConfessionAnim
// (Final, Native, Public, BlueprintCallable)

void UInteractionV3FaceAnimInstance::StopConfessionAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionV3FaceAnimInstance", "StopConfessionAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionV3FaceAnimInstance.StopLastFrameAnim
// (Final, Native, Public, BlueprintCallable)

void UInteractionV3FaceAnimInstance::StopLastFrameAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionV3FaceAnimInstance", "StopLastFrameAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionV3FunctionLibrary.ActiveCameraBlendOut
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInForceCameraBlend                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionV3FunctionLibrary::ActiveCameraBlendOut(const class UObject* WorldContextObject, bool bInForceCameraBlend)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InteractionV3FunctionLibrary", "ActiveCameraBlendOut");

	Params::InteractionV3FunctionLibrary_ActiveCameraBlendOut Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.bInForceCameraBlend = bInForceCameraBlend;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionV3FunctionLibrary.CalculateBezierPoint
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   T                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Current                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Target                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UInteractionV3FunctionLibrary::CalculateBezierPoint(float T, const struct FVector& Current, const struct FVector& Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InteractionV3FunctionLibrary", "CalculateBezierPoint");

	Params::InteractionV3FunctionLibrary_CalculateBezierPoint Parms{};

	Parms.T = T;
	Parms.Current = std::move(Current);
	Parms.Target = std::move(Target);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionV3FunctionLibrary.CreateUniversalCamera
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AUniversalCameraActor*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AUniversalCameraActor* UInteractionV3FunctionLibrary::CreateUniversalCamera(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InteractionV3FunctionLibrary", "CreateUniversalCamera");

	Params::InteractionV3FunctionLibrary_CreateUniversalCamera Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionV3FunctionLibrary.DeactiveCameraBlendOut
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionV3FunctionLibrary::DeactiveCameraBlendOut(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InteractionV3FunctionLibrary", "DeactiveCameraBlendOut");

	Params::InteractionV3FunctionLibrary_DeactiveCameraBlendOut Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionV3FunctionLibrary.GetActiveScenarioNodeInnerState
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EScenarioNodeInnerState                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EScenarioNodeInnerState UInteractionV3FunctionLibrary::GetActiveScenarioNodeInnerState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InteractionV3FunctionLibrary", "GetActiveScenarioNodeInnerState");

	Params::InteractionV3FunctionLibrary_GetActiveScenarioNodeInnerState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionV3FunctionLibrary.GetActiveScenarioStateNode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UScenarioStateNode*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UScenarioStateNode* UInteractionV3FunctionLibrary::GetActiveScenarioStateNode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InteractionV3FunctionLibrary", "GetActiveScenarioStateNode");

	Params::InteractionV3FunctionLibrary_GetActiveScenarioStateNode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionV3FunctionLibrary.GetCurrentOperateName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UInteractionV3FunctionLibrary::GetCurrentOperateName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InteractionV3FunctionLibrary", "GetCurrentOperateName");

	Params::InteractionV3FunctionLibrary_GetCurrentOperateName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionV3FunctionLibrary.GetOperateDragOffset
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UInteractionV3FunctionLibrary::GetOperateDragOffset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InteractionV3FunctionLibrary", "GetOperateDragOffset");

	Params::InteractionV3FunctionLibrary_GetOperateDragOffset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionV3FunctionLibrary.GetOperateDragValue
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UInteractionV3FunctionLibrary::GetOperateDragValue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InteractionV3FunctionLibrary", "GetOperateDragValue");

	Params::InteractionV3FunctionLibrary_GetOperateDragValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionV3FunctionLibrary.GetOperateInputControl
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UInteractionV3InputControl*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractionV3InputControl* UInteractionV3FunctionLibrary::GetOperateInputControl()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InteractionV3FunctionLibrary", "GetOperateInputControl");

	Params::InteractionV3FunctionLibrary_GetOperateInputControl Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionV3FunctionLibrary.GetTiltOffset
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   InOffset                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  CameraRotation                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// const float&                            OffsetAdditiveRot_Pitch                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float&                            OffsetAdditiveRot_Yaw                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UInteractionV3FunctionLibrary::GetTiltOffset(const struct FVector& InOffset, const struct FRotator& CameraRotation, const float& OffsetAdditiveRot_Pitch, const float& OffsetAdditiveRot_Yaw)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InteractionV3FunctionLibrary", "GetTiltOffset");

	Params::InteractionV3FunctionLibrary_GetTiltOffset Parms{};

	Parms.InOffset = std::move(InOffset);
	Parms.CameraRotation = std::move(CameraRotation);
	Parms.OffsetAdditiveRot_Pitch = OffsetAdditiveRot_Pitch;
	Parms.OffsetAdditiveRot_Yaw = OffsetAdditiveRot_Yaw;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionV3FunctionLibrary.LineTraceComponentOnMousePos
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult*                      OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              InPrimitiveComp                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUsePressedPos                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionV3FunctionLibrary::LineTraceComponentOnMousePos(class UObject* WorldContextObject, struct FHitResult* OutHit, class UPrimitiveComponent* InPrimitiveComp, bool bUsePressedPos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InteractionV3FunctionLibrary", "LineTraceComponentOnMousePos");

	Params::InteractionV3FunctionLibrary_LineTraceComponentOnMousePos Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InPrimitiveComp = InPrimitiveComp;
	Parms.bUsePressedPos = bUsePressedPos;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionV3FunctionLibrary.LockCameraBlendOutChange
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionV3FunctionLibrary::LockCameraBlendOutChange(const class UObject* WorldContextObject, bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InteractionV3FunctionLibrary", "LockCameraBlendOutChange");

	Params::InteractionV3FunctionLibrary_LockCameraBlendOutChange Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionV3FunctionLibrary.SetActorHiddenInGame
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AInteractionActorV3*              InteractionActorV3                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHidden                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionV3FunctionLibrary::SetActorHiddenInGame(class AInteractionActorV3* InteractionActorV3, bool bHidden)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InteractionV3FunctionLibrary", "SetActorHiddenInGame");

	Params::InteractionV3FunctionLibrary_SetActorHiddenInGame Parms{};

	Parms.InteractionActorV3 = InteractionActorV3;
	Parms.bHidden = bHidden;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionV3FunctionLibrary.SetViewTargetToUniversalCamera
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUniversalCameraInfo*            CameraInfo                                             (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// class FName                             ModeName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AUniversalCameraActor*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AUniversalCameraActor* UInteractionV3FunctionLibrary::SetViewTargetToUniversalCamera(class UObject* WorldContextObject, struct FUniversalCameraInfo* CameraInfo, class FName ModeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InteractionV3FunctionLibrary", "SetViewTargetToUniversalCamera");

	Params::InteractionV3FunctionLibrary_SetViewTargetToUniversalCamera Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ModeName = ModeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (CameraInfo != nullptr)
		*CameraInfo = std::move(Parms.CameraInfo);

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionV3FunctionLibrary.SimpleFloatSpringInterp
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// float                                   Current                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float&                                  Velocity                                               (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Stiffness                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Damping                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   VelocityClamp                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInteractionV3FunctionLibrary::SimpleFloatSpringInterp(float Current, float Target, float& Velocity, float Stiffness, float Damping, float DeltaTime, float VelocityClamp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InteractionV3FunctionLibrary", "SimpleFloatSpringInterp");

	Params::InteractionV3FunctionLibrary_SimpleFloatSpringInterp Parms{};

	Parms.Current = Current;
	Parms.Target = Target;
	Parms.Velocity = Velocity;
	Parms.Stiffness = Stiffness;
	Parms.Damping = Damping;
	Parms.DeltaTime = DeltaTime;
	Parms.VelocityClamp = VelocityClamp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Velocity = Parms.Velocity;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionV3FunctionLibrary.SimpleVectorSpringInterp
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Current                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector&                         Velocity                                               (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Stiffness                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Damping                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   VelocityClamp                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UInteractionV3FunctionLibrary::SimpleVectorSpringInterp(const struct FVector& Current, const struct FVector& Target, struct FVector& Velocity, const struct FVector& Stiffness, const struct FVector& Damping, float DeltaTime, float VelocityClamp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InteractionV3FunctionLibrary", "SimpleVectorSpringInterp");

	Params::InteractionV3FunctionLibrary_SimpleVectorSpringInterp Parms{};

	Parms.Current = std::move(Current);
	Parms.Target = std::move(Target);
	Parms.Velocity = std::move(Velocity);
	Parms.Stiffness = std::move(Stiffness);
	Parms.Damping = std::move(Damping);
	Parms.DeltaTime = DeltaTime;
	Parms.VelocityClamp = VelocityClamp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Velocity = std::move(Parms.Velocity);

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionV3CableFunctionLibrary.GetCableLengthRuntime
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const TArray<struct FVector>&           CablePoints                                            (ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInteractionV3CableFunctionLibrary::GetCableLengthRuntime(const TArray<struct FVector>& CablePoints)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InteractionV3CableFunctionLibrary", "GetCableLengthRuntime");

	Params::InteractionV3CableFunctionLibrary_GetCableLengthRuntime Parms{};

	Parms.CablePoints = std::move(CablePoints);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionV3CableFunctionLibrary.GetCableLengthRuntimeAtIndex
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const TArray<struct FVector>&           CablePoints                                            (ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInteractionV3CableFunctionLibrary::GetCableLengthRuntimeAtIndex(const TArray<struct FVector>& CablePoints, int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InteractionV3CableFunctionLibrary", "GetCableLengthRuntimeAtIndex");

	Params::InteractionV3CableFunctionLibrary_GetCableLengthRuntimeAtIndex Parms{};

	Parms.CablePoints = std::move(CablePoints);
	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionV3CableFunctionLibrary.GetCablePoints
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UCableComponent*            CableComponent                                         (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FVector>&           AdditionalPoints                                       (ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    bToEnd                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FVector> UInteractionV3CableFunctionLibrary::GetCablePoints(const class UCableComponent* CableComponent, const TArray<struct FVector>& AdditionalPoints, bool bToEnd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InteractionV3CableFunctionLibrary", "GetCablePoints");

	Params::InteractionV3CableFunctionLibrary_GetCablePoints Parms{};

	Parms.CableComponent = CableComponent;
	Parms.AdditionalPoints = std::move(AdditionalPoints);
	Parms.bToEnd = bToEnd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionV3CableFunctionLibrary.GetLocationOnCableByPercentage
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const TArray<struct FVector>&           CablePoints                                            (ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// float                                   _percentage                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UInteractionV3CableFunctionLibrary::GetLocationOnCableByPercentage(const TArray<struct FVector>& CablePoints, float _percentage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InteractionV3CableFunctionLibrary", "GetLocationOnCableByPercentage");

	Params::InteractionV3CableFunctionLibrary_GetLocationOnCableByPercentage Parms{};

	Parms.CablePoints = std::move(CablePoints);
	Parms._percentage = _percentage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionV3CableFunctionLibrary.GetLowestLocationIndexOnCable
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const TArray<struct FVector>&           CablePoints                                            (ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UInteractionV3CableFunctionLibrary::GetLowestLocationIndexOnCable(const TArray<struct FVector>& CablePoints)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InteractionV3CableFunctionLibrary", "GetLowestLocationIndexOnCable");

	Params::InteractionV3CableFunctionLibrary_GetLowestLocationIndexOnCable Parms{};

	Parms.CablePoints = std::move(CablePoints);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionV3CableFunctionLibrary.GetLowestLocationOnCable
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const TArray<struct FVector>&           CablePoints                                            (ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UInteractionV3CableFunctionLibrary::GetLowestLocationOnCable(const TArray<struct FVector>& CablePoints)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InteractionV3CableFunctionLibrary", "GetLowestLocationOnCable");

	Params::InteractionV3CableFunctionLibrary_GetLowestLocationOnCable Parms{};

	Parms.CablePoints = std::move(CablePoints);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionV3CableFunctionLibrary.GetPercentageByParticleIndex
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const TArray<struct FVector>&           CablePoints                                            (ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                                   _Index                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInteractionV3CableFunctionLibrary::GetPercentageByParticleIndex(const TArray<struct FVector>& CablePoints, int32 _Index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InteractionV3CableFunctionLibrary", "GetPercentageByParticleIndex");

	Params::InteractionV3CableFunctionLibrary_GetPercentageByParticleIndex Parms{};

	Parms.CablePoints = std::move(CablePoints);
	Parms._Index = _Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionV3CableFunctionLibrary.GetSideLocationOnCableByPercentage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const TArray<struct FVector>&           CablePoints                                            (ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// float                                   _percentage                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FVector> UInteractionV3CableFunctionLibrary::GetSideLocationOnCableByPercentage(const TArray<struct FVector>& CablePoints, float _percentage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InteractionV3CableFunctionLibrary", "GetSideLocationOnCableByPercentage");

	Params::InteractionV3CableFunctionLibrary_GetSideLocationOnCableByPercentage Parms{};

	Parms.CablePoints = std::move(CablePoints);
	Parms._percentage = _percentage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionV3CableFunctionLibrary.SpringInterpFloat
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   _Target                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   _Current                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  _Velocity                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FVector>&           CablePoints                                            (ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// float                                   _Stiffness                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   _Damping                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   _VelocityClamp                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   _HeightScale                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInteractionV3CableFunctionLibrary::SpringInterpFloat(float DeltaTime, float _Target, float _Current, float* _Velocity, const TArray<struct FVector>& CablePoints, float _Stiffness, float _Damping, float _VelocityClamp, float _HeightScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InteractionV3CableFunctionLibrary", "SpringInterpFloat");

	Params::InteractionV3CableFunctionLibrary_SpringInterpFloat Parms{};

	Parms.DeltaTime = DeltaTime;
	Parms._Target = _Target;
	Parms._Current = _Current;
	Parms.CablePoints = std::move(CablePoints);
	Parms._Stiffness = _Stiffness;
	Parms._Damping = _Damping;
	Parms._VelocityClamp = _VelocityClamp;
	Parms._HeightScale = _HeightScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (_Velocity != nullptr)
		*_Velocity = Parms._Velocity;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionV3Lib.ClearInteractionStat
// (Final, Native, Static, Public, BlueprintCallable)

void UInteractionV3Lib::ClearInteractionStat()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InteractionV3Lib", "ClearInteractionStat");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionV3Lib.GetInteractionStringStat
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    StatName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UInteractionV3Lib::GetInteractionStringStat(const class FString& StatName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InteractionV3Lib", "GetInteractionStringStat");

	Params::InteractionV3Lib_GetInteractionStringStat Parms{};

	Parms.StatName = std::move(StatName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionV3Lib.GetInterationBoolStat
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    StatName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionV3Lib::GetInterationBoolStat(const class FString& StatName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InteractionV3Lib", "GetInterationBoolStat");

	Params::InteractionV3Lib_GetInterationBoolStat Parms{};

	Parms.StatName = std::move(StatName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionV3Lib.GetInterationIntStat
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    StatName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UInteractionV3Lib::GetInterationIntStat(const class FString& StatName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InteractionV3Lib", "GetInterationIntStat");

	Params::InteractionV3Lib_GetInterationIntStat Parms{};

	Parms.StatName = std::move(StatName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionV3Lib.HasInteractionBoolStat
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    StatName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionV3Lib::HasInteractionBoolStat(const class FString& StatName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InteractionV3Lib", "HasInteractionBoolStat");

	Params::InteractionV3Lib_HasInteractionBoolStat Parms{};

	Parms.StatName = std::move(StatName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionV3Lib.HasInteractionIntStat
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    StatName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionV3Lib::HasInteractionIntStat(const class FString& StatName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InteractionV3Lib", "HasInteractionIntStat");

	Params::InteractionV3Lib_HasInteractionIntStat Parms{};

	Parms.StatName = std::move(StatName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionV3Lib.HasInteractionStringStat
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    StatName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionV3Lib::HasInteractionStringStat(const class FString& StatName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InteractionV3Lib", "HasInteractionStringStat");

	Params::InteractionV3Lib_HasInteractionStringStat Parms{};

	Parms.StatName = std::move(StatName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.InteractionV3Lib.SetInteractionBoolStat
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    StatName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    StatValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionV3Lib::SetInteractionBoolStat(const class FString& StatName, bool StatValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InteractionV3Lib", "SetInteractionBoolStat");

	Params::InteractionV3Lib_SetInteractionBoolStat Parms{};

	Parms.StatName = std::move(StatName);
	Parms.StatValue = StatValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionV3Lib.SetInteractionIntStat
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    StatName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StatValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionV3Lib::SetInteractionIntStat(const class FString& StatName, int32 StatValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InteractionV3Lib", "SetInteractionIntStat");

	Params::InteractionV3Lib_SetInteractionIntStat Parms{};

	Parms.StatName = std::move(StatName);
	Parms.StatValue = StatValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionV3Lib.SetInteractionStringStat
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    StatName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    StatValue                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionV3Lib::SetInteractionStringStat(const class FString& StatName, const class FString& StatValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InteractionV3Lib", "SetInteractionStringStat");

	Params::InteractionV3Lib_SetInteractionStringStat Parms{};

	Parms.StatName = std::move(StatName);
	Parms.StatValue = std::move(StatValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.InteractionV3Trigger.CanTrigger
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionV3Trigger::CanTrigger() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionV3Trigger", "CanTrigger");

	Params::InteractionV3Trigger_CanTrigger Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ScenarioMagicCardLittleGame.QInterpTo
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FRotator&                  Current                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// const struct FRotator&                  Target                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InterpSpeed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UScenarioMagicCardLittleGame::QInterpTo(const struct FRotator& Current, const struct FRotator& Target, float DeltaTime, float InterpSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ScenarioMagicCardLittleGame", "QInterpTo");

	Params::ScenarioMagicCardLittleGame_QInterpTo Parms{};

	Parms.Current = std::move(Current);
	Parms.Target = std::move(Target);
	Parms.DeltaTime = DeltaTime;
	Parms.InterpSpeed = InterpSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ScenarioOperate.Complete
// (Native, Public, BlueprintCallable)

void UScenarioOperate::Complete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioOperate", "Complete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioOperate.GetOperateState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EScenarioOperateState                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EScenarioOperateState UScenarioOperate::GetOperateState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioOperate", "GetOperateState");

	Params::ScenarioOperate_GetOperateState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ScenarioOperate.GetStandbyCameraIDs
// (Final, Native, Public, Const)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UScenarioOperate::GetStandbyCameraIDs() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioOperate", "GetStandbyCameraIDs");

	Params::ScenarioOperate_GetStandbyCameraIDs Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ScenarioOperate.IsCompleteAndBlendOut
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UScenarioOperate::IsCompleteAndBlendOut() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioOperate", "IsCompleteAndBlendOut");

	Params::ScenarioOperate_IsCompleteAndBlendOut Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ScenarioStateComponent.Play
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UScenarioStateMachine*            InScenario                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UScenarioStateComponent::Play(class UScenarioStateMachine* InScenario)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateComponent", "Play");

	Params::ScenarioStateComponent_Play Parms{};

	Parms.InScenario = InScenario;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ScenarioStateComponent.GetActiveStateMachine
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UScenarioStateMachine*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UScenarioStateMachine* UScenarioStateComponent::GetActiveStateMachine() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateComponent", "GetActiveStateMachine");

	Params::ScenarioStateComponent_GetActiveStateMachine Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ScenarioStateComponent.GetInteractionDirector
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AInteractionDirectorV3*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AInteractionDirectorV3* UScenarioStateComponent::GetInteractionDirector() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateComponent", "GetInteractionDirector");

	Params::ScenarioStateComponent_GetInteractionDirector Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ScenarioStateComponent.GetLastActiveStateMachine
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UScenarioStateMachine*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UScenarioStateMachine* UScenarioStateComponent::GetLastActiveStateMachine() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateComponent", "GetLastActiveStateMachine");

	Params::ScenarioStateComponent_GetLastActiveStateMachine Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ScenarioStateComponent.TransitionState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FString&                    InScenarioStateName                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UScenarioStateComponent::TransitionState(const class FString& InScenarioStateName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateComponent", "TransitionState");

	Params::ScenarioStateComponent_TransitionState Parms{};

	Parms.InScenarioStateName = std::move(InScenarioStateName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ScenarioStateMachine.End
// (Native, Public, BlueprintCallable)

void UScenarioStateMachine::End()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateMachine", "End");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateMachine.EndLastShowElement
// (Final, Native, Public, BlueprintCallable)

void UScenarioStateMachine::EndLastShowElement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateMachine", "EndLastShowElement");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateMachine.GetConstRecordShowElementPlayInfo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FScenarioShowElementPlayInfoReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

const struct FScenarioShowElementPlayInfo UScenarioStateMachine::GetConstRecordShowElementPlayInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateMachine", "GetConstRecordShowElementPlayInfo");

	Params::ScenarioStateMachine_GetConstRecordShowElementPlayInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ScenarioStateMachine.GetRecordShowElementPlayInfo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FScenarioShowElementPlayInfo     ReturnValue                                            (Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FScenarioShowElementPlayInfo UScenarioStateMachine::GetRecordShowElementPlayInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateMachine", "GetRecordShowElementPlayInfo");

	Params::ScenarioStateMachine_GetRecordShowElementPlayInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ScenarioStateMachine.GetScenarioStateContext
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FScenarioStateContext            ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FScenarioStateContext UScenarioStateMachine::GetScenarioStateContext()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateMachine", "GetScenarioStateContext");

	Params::ScenarioStateMachine_GetScenarioStateContext Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ScenarioStateMachine.Initialize
// (Native, Public, BlueprintCallable)

void UScenarioStateMachine::Initialize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateMachine", "Initialize");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateMachine.OnPlayShowElement
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FScenarioShowElementPlayInfo&InPlayInfo                                             (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UScenarioStateMachine::OnPlayShowElement(const struct FScenarioShowElementPlayInfo& InPlayInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateMachine", "OnPlayShowElement");

	Params::ScenarioStateMachine_OnPlayShowElement Parms{};

	Parms.InPlayInfo = std::move(InPlayInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateMachine.QuitLastShowElement
// (Final, Native, Public, BlueprintCallable)

void UScenarioStateMachine::QuitLastShowElement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateMachine", "QuitLastShowElement");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateMachine.ResetActors
// (Final, Native, Protected, BlueprintCallable)

void UScenarioStateMachine::ResetActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateMachine", "ResetActors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateMachine.Start
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FScenarioStateContext&     InContext                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UScenarioStateMachine::Start(const struct FScenarioStateContext& InContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateMachine", "Start");

	Params::ScenarioStateMachine_Start Parms{};

	Parms.InContext = std::move(InContext);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateMachine.Transition
// (Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    ToStateNodeName                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UScenarioStateMachine::Transition(const class FString& ToStateNodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateMachine", "Transition");

	Params::ScenarioStateMachine_Transition Parms{};

	Parms.ToStateNodeName = std::move(ToStateNodeName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ScenarioStateMachine.Update
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScenarioStateMachine::Update(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateMachine", "Update");

	Params::ScenarioStateMachine_Update Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateMachine.GetActiveNode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UScenarioStateNode*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UScenarioStateNode* UScenarioStateMachine::GetActiveNode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateMachine", "GetActiveNode");

	Params::ScenarioStateMachine_GetActiveNode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ScenarioStateMachine.GetDebugInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UScenarioStateMachine::GetDebugInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateMachine", "GetDebugInfo");

	Params::ScenarioStateMachine_GetDebugInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ScenarioStateMachine.GetProcessor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UScenarioStateMachineStandardProcessor*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UScenarioStateMachineStandardProcessor* UScenarioStateMachine::GetProcessor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateMachine", "GetProcessor");

	Params::ScenarioStateMachine_GetProcessor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ScenarioStateMachine.GetRecordPlayShowElement
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UScenarioStateMachine::GetRecordPlayShowElement() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateMachine", "GetRecordPlayShowElement");

	Params::ScenarioStateMachine_GetRecordPlayShowElement Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ScenarioStateMachine.GetStateNodeByName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FString&                    InStateName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UScenarioStateNode*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UScenarioStateNode* UScenarioStateMachine::GetStateNodeByName(const class FString& InStateName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateMachine", "GetStateNodeByName");

	Params::ScenarioStateMachine_GetStateNodeByName Parms{};

	Parms.InStateName = std::move(InStateName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ScenarioStateMachineProcessorBase.End
// (Native, Public, BlueprintCallable)

void UScenarioStateMachineProcessorBase::End()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateMachineProcessorBase", "End");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateMachineProcessorBase.Initialize
// (Native, Public, BlueprintCallable)
// Parameters:
// class UScenarioStateMachine*            InStateMachine                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScenarioStateMachineProcessorBase::Initialize(class UScenarioStateMachine* InStateMachine)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateMachineProcessorBase", "Initialize");

	Params::ScenarioStateMachineProcessorBase_Initialize Parms{};

	Parms.InStateMachine = InStateMachine;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateMachineProcessorBase.OnEnd
// (Native, Event, Public, BlueprintEvent)

void UScenarioStateMachineProcessorBase::OnEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateMachineProcessorBase", "OnEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateMachineProcessorBase.OnInitialize
// (Native, Event, Public, BlueprintEvent)

void UScenarioStateMachineProcessorBase::OnInitialize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateMachineProcessorBase", "OnInitialize");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateMachineProcessorBase.OnPostStart
// (Native, Event, Public, BlueprintEvent)

void UScenarioStateMachineProcessorBase::OnPostStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateMachineProcessorBase", "OnPostStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateMachineProcessorBase.OnStart
// (Native, Event, Public, BlueprintEvent)

void UScenarioStateMachineProcessorBase::OnStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateMachineProcessorBase", "OnStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateMachineProcessorBase.OnUpdate
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScenarioStateMachineProcessorBase::OnUpdate(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateMachineProcessorBase", "OnUpdate");

	Params::ScenarioStateMachineProcessorBase_OnUpdate Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateMachineProcessorBase.PostStart
// (Native, Public, BlueprintCallable)

void UScenarioStateMachineProcessorBase::PostStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateMachineProcessorBase", "PostStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateMachineProcessorBase.Start
// (Native, Public, BlueprintCallable)

void UScenarioStateMachineProcessorBase::Start()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateMachineProcessorBase", "Start");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateMachineProcessorBase.Update
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScenarioStateMachineProcessorBase::Update(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateMachineProcessorBase", "Update");

	Params::ScenarioStateMachineProcessorBase_Update Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateMachineProcessorBase.GetDirectorV3
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AInteractionDirectorV3*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AInteractionDirectorV3* UScenarioStateMachineProcessorBase::GetDirectorV3() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateMachineProcessorBase", "GetDirectorV3");

	Params::ScenarioStateMachineProcessorBase_GetDirectorV3 Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ScenarioStateMachineProcessorBase.GetStateMachine
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UScenarioStateMachine*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UScenarioStateMachine* UScenarioStateMachineProcessorBase::GetStateMachine() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateMachineProcessorBase", "GetStateMachine");

	Params::ScenarioStateMachineProcessorBase_GetStateMachine Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ScenarioStateMachineStandardProcessor.ClearLevelSequence
// (Final, Native, Public, BlueprintCallable)

void UScenarioStateMachineStandardProcessor::ClearLevelSequence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateMachineStandardProcessor", "ClearLevelSequence");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateMachineStandardProcessor.GetPlaySequenceReason
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UScenarioStateMachineStandardProcessor::GetPlaySequenceReason()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateMachineStandardProcessor", "GetPlaySequenceReason");

	Params::ScenarioStateMachineStandardProcessor_GetPlaySequenceReason Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ScenarioStateMachineStandardProcessor.K2_OnPlayShowElement
// (Event, Public, BlueprintEvent)
// Parameters:
// const class FString&                    InElementName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScenarioStateMachineStandardProcessor::K2_OnPlayShowElement(const class FString& InElementName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateMachineStandardProcessor", "K2_OnPlayShowElement");

	Params::ScenarioStateMachineStandardProcessor_K2_OnPlayShowElement Parms{};

	Parms.InElementName = std::move(InElementName);

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharacterInteractionV3.ScenarioStateMachineStandardProcessor.OnPlayShowElement
// (Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    InElementName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScenarioStateMachineStandardProcessor::OnPlayShowElement(const class FString& InElementName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateMachineStandardProcessor", "OnPlayShowElement");

	Params::ScenarioStateMachineStandardProcessor_OnPlayShowElement Parms{};

	Parms.InElementName = std::move(InElementName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateMachineStandardProcessor.OnSequenceFinished
// (Final, Native, Protected)

void UScenarioStateMachineStandardProcessor::OnSequenceFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateMachineStandardProcessor", "OnSequenceFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateMachineStandardProcessor.PlayInitLevelSequence
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TSoftObjectPtr<class ULevelSequence>InSequence                                             (ConstParm, Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScenarioStateMachineStandardProcessor::PlayInitLevelSequence(const TSoftObjectPtr<class ULevelSequence> InSequence)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateMachineStandardProcessor", "PlayInitLevelSequence");

	Params::ScenarioStateMachineStandardProcessor_PlayInitLevelSequence Parms{};

	Parms.InSequence = InSequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateMachineStandardProcessor.PlayLevelSequence
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TSoftObjectPtr<class ULevelSequence>InSequence                                             (ConstParm, Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    InReason                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             StartFrame                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             Duration                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALevelSequenceActor*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALevelSequenceActor* UScenarioStateMachineStandardProcessor::PlayLevelSequence(const TSoftObjectPtr<class ULevelSequence> InSequence, const class FString& InReason, const int32 StartFrame, const int32 Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateMachineStandardProcessor", "PlayLevelSequence");

	Params::ScenarioStateMachineStandardProcessor_PlayLevelSequence Parms{};

	Parms.InSequence = InSequence;
	Parms.InReason = std::move(InReason);
	Parms.StartFrame = StartFrame;
	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ScenarioStateMachineStandardProcessor.SetActorsLocAndRotByPosName
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      PosActorName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScenarioStateMachineStandardProcessor::SetActorsLocAndRotByPosName(const class FName& PosActorName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateMachineStandardProcessor", "SetActorsLocAndRotByPosName");

	Params::ScenarioStateMachineStandardProcessor_SetActorsLocAndRotByPosName Parms{};

	Parms.PosActorName = PosActorName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateMachineStandardProcessor.GetActorByName
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName&                      InActorName                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UScenarioStateMachineStandardProcessor::GetActorByName(const class FName& InActorName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateMachineStandardProcessor", "GetActorByName");

	Params::ScenarioStateMachineStandardProcessor_GetActorByName Parms{};

	Parms.InActorName = InActorName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ScenarioStateMachineStandardProcessor.GetPlaySequence
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ALevelSequenceActor*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALevelSequenceActor* UScenarioStateMachineStandardProcessor::GetPlaySequence() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateMachineStandardProcessor", "GetPlaySequence");

	Params::ScenarioStateMachineStandardProcessor_GetPlaySequence Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ScenarioStateMachineStandardProcessor.StopVoice
// (Final, Native, Public, BlueprintCallable, Const)

void UScenarioStateMachineStandardProcessor::StopVoice() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateMachineStandardProcessor", "StopVoice");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateMachineProcessor_TessMarry.GetCardInfo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InCardIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMagicCardInfo             ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FMagicCardInfo UScenarioStateMachineProcessor_TessMarry::GetCardInfo(int32 InCardIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateMachineProcessor_TessMarry", "GetCardInfo");

	Params::ScenarioStateMachineProcessor_TessMarry_GetCardInfo Parms{};

	Parms.InCardIndex = InCardIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ScenarioStateMachineProcessor_TessMarry.RandomLineIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UScenarioStateMachineProcessor_TessMarry::RandomLineIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateMachineProcessor_TessMarry", "RandomLineIndex");

	Params::ScenarioStateMachineProcessor_TessMarry_RandomLineIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ScenarioStateNodeBase.Enter
// (Native, Public, BlueprintCallable)

void UScenarioStateNodeBase::Enter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNodeBase", "Enter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateNodeBase.Exit
// (Native, Public, BlueprintCallable)

void UScenarioStateNodeBase::Exit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNodeBase", "Exit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateNodeBase.Initialize
// (Native, Public, BlueprintCallable)

void UScenarioStateNodeBase::Initialize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNodeBase", "Initialize");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateNodeBase.OnEnter
// (Native, Event, Public, BlueprintEvent)

void UScenarioStateNodeBase::OnEnter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNodeBase", "OnEnter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateNodeBase.OnExit
// (Native, Event, Public, BlueprintEvent)

void UScenarioStateNodeBase::OnExit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNodeBase", "OnExit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateNodeBase.OnInitialize
// (Native, Event, Public, BlueprintEvent)

void UScenarioStateNodeBase::OnInitialize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNodeBase", "OnInitialize");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateNodeBase.OnPostEnter
// (Native, Event, Public, BlueprintEvent)

void UScenarioStateNodeBase::OnPostEnter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNodeBase", "OnPostEnter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateNodeBase.OnPreEnter
// (Native, Event, Public, BlueprintEvent)

void UScenarioStateNodeBase::OnPreEnter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNodeBase", "OnPreEnter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateNodeBase.OnReady
// (Native, Event, Public, BlueprintEvent)

void UScenarioStateNodeBase::OnReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNodeBase", "OnReady");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateNodeBase.OnStartStandby
// (Native, Event, Public, BlueprintEvent)

void UScenarioStateNodeBase::OnStartStandby()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNodeBase", "OnStartStandby");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateNodeBase.OnUpdate
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScenarioStateNodeBase::OnUpdate(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNodeBase", "OnUpdate");

	Params::ScenarioStateNodeBase_OnUpdate Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateNodeBase.PostEnter
// (Native, Public, BlueprintCallable)

void UScenarioStateNodeBase::PostEnter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNodeBase", "PostEnter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateNodeBase.PreEnter
// (Native, Public, BlueprintCallable)

void UScenarioStateNodeBase::PreEnter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNodeBase", "PreEnter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateNodeBase.Ready
// (Native, Public, BlueprintCallable)

void UScenarioStateNodeBase::Ready()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNodeBase", "Ready");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateNodeBase.SetNodeStage
// (Native, Public, BlueprintCallable)
// Parameters:
// const EScenarioNodeStage                NewStage                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScenarioStateNodeBase::SetNodeStage(const EScenarioNodeStage NewStage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNodeBase", "SetNodeStage");

	Params::ScenarioStateNodeBase_SetNodeStage Parms{};

	Parms.NewStage = NewStage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateNodeBase.StartStandby
// (Native, Public, BlueprintCallable)

void UScenarioStateNodeBase::StartStandby()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNodeBase", "StartStandby");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateNodeBase.Update
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScenarioStateNodeBase::Update(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNodeBase", "Update");

	Params::ScenarioStateNodeBase_Update Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateNodeBase.GetHolyLightComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UHolyLightV3Component*            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UHolyLightV3Component* UScenarioStateNodeBase::GetHolyLightComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNodeBase", "GetHolyLightComponent");

	Params::ScenarioStateNodeBase_GetHolyLightComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ScenarioStateNodeBase.GetInteractionDirector
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AInteractionDirectorV3*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AInteractionDirectorV3* UScenarioStateNodeBase::GetInteractionDirector() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNodeBase", "GetInteractionDirector");

	Params::ScenarioStateNodeBase_GetInteractionDirector Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ScenarioStateNodeBase.GetInteractionInputComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInteractionInputComponent*       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractionInputComponent* UScenarioStateNodeBase::GetInteractionInputComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNodeBase", "GetInteractionInputComponent");

	Params::ScenarioStateNodeBase_GetInteractionInputComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ScenarioStateNodeBase.GetInteractionPlayV3
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AInteractionPlayV3*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AInteractionPlayV3* UScenarioStateNodeBase::GetInteractionPlayV3() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNodeBase", "GetInteractionPlayV3");

	Params::ScenarioStateNodeBase_GetInteractionPlayV3 Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ScenarioStateNodeBase.GetNodeStage
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EScenarioNodeStage                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EScenarioNodeStage UScenarioStateNodeBase::GetNodeStage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNodeBase", "GetNodeStage");

	Params::ScenarioStateNodeBase_GetNodeStage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ScenarioStateNodeBase.GetStateComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UScenarioStateComponent*          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UScenarioStateComponent* UScenarioStateNodeBase::GetStateComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNodeBase", "GetStateComponent");

	Params::ScenarioStateNodeBase_GetStateComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ScenarioStateNodeBase.GetStateMachine
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UScenarioStateMachine*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UScenarioStateMachine* UScenarioStateNodeBase::GetStateMachine() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNodeBase", "GetStateMachine");

	Params::ScenarioStateNodeBase_GetStateMachine Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ScenarioStateNodeBase.GetStateMachineProcessor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UScenarioStateMachineStandardProcessor*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UScenarioStateMachineStandardProcessor* UScenarioStateNodeBase::GetStateMachineProcessor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNodeBase", "GetStateMachineProcessor");

	Params::ScenarioStateNodeBase_GetStateMachineProcessor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ScenarioStateNodeBase.IsActive
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UScenarioStateNodeBase::IsActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNodeBase", "IsActive");

	Params::ScenarioStateNodeBase_IsActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ScenarioStateNode.ActiveStandbyCamera
// (Native, Public, BlueprintCallable)

void UScenarioStateNode::ActiveStandbyCamera()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNode", "ActiveStandbyCamera");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateNode.AddToExecutableOperates
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<class UInteractionOperateV3*>&InOperates                                             (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UScenarioStateNode::AddToExecutableOperates(const TArray<class UInteractionOperateV3*>& InOperates)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNode", "AddToExecutableOperates");

	Params::ScenarioStateNode_AddToExecutableOperates Parms{};

	Parms.InOperates = std::move(InOperates);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateNode.AppendShowElementListByCallback
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<class FString>&            InElements                                             (ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// const class FString&                    NextState                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       OnShowElementPlayFinish                                (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void UScenarioStateNode::AppendShowElementListByCallback(const TArray<class FString>& InElements, const class FString& NextState, TDelegate<void()> OnShowElementPlayFinish)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNode", "AppendShowElementListByCallback");

	Params::ScenarioStateNode_AppendShowElementListByCallback Parms{};

	Parms.InElements = std::move(InElements);
	Parms.NextState = std::move(NextState);
	Parms.OnShowElementPlayFinish = OnShowElementPlayFinish;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateNode.DisableInput
// (Final, Native, Public, BlueprintCallable)

void UScenarioStateNode::DisableInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNode", "DisableInput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateNode.EnableInput
// (Final, Native, Public, BlueprintCallable)

void UScenarioStateNode::EnableInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNode", "EnableInput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateNode.GetCurrentPressedCollisionName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UScenarioStateNode::GetCurrentPressedCollisionName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNode", "GetCurrentPressedCollisionName");

	Params::ScenarioStateNode_GetCurrentPressedCollisionName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ScenarioStateNode.GetDebugInfo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UScenarioStateNode::GetDebugInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNode", "GetDebugInfo");

	Params::ScenarioStateNode_GetDebugInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ScenarioStateNode.GetStateActorNames
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSet<class FName>*                      StateNames                                             (Parm, OutParm, NativeAccessSpecifierPublic)

void UScenarioStateNode::GetStateActorNames(TSet<class FName>* StateNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNode", "GetStateActorNames");

	Params::ScenarioStateNode_GetStateActorNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (StateNames != nullptr)
		*StateNames = std::move(Parms.StateNames);
}


// Function CharacterInteractionV3.ScenarioStateNode.HideAllActors
// (Final, Native, Public, BlueprintCallable)

void UScenarioStateNode::HideAllActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNode", "HideAllActors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateNode.HideOtherActor
// (Native, Public, BlueprintCallable)

void UScenarioStateNode::HideOtherActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNode", "HideOtherActor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateNode.ListenForInputAction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ActionName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputEvent                             EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConsume                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       Callback                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UScenarioStateNode::ListenForInputAction(class FName ActionName, EInputEvent EventType, bool bConsume, TDelegate<void()> Callback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNode", "ListenForInputAction");

	Params::ScenarioStateNode_ListenForInputAction Parms{};

	Parms.ActionName = ActionName;
	Parms.EventType = EventType;
	Parms.bConsume = bConsume;
	Parms.Callback = Callback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ScenarioStateNode.ListenForKeyAction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FKey&                      InKey                                                  (ConstParm, Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputEvent                             EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConsume                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       Callback                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void UScenarioStateNode::ListenForKeyAction(const struct FKey& InKey, EInputEvent EventType, bool bConsume, TDelegate<void()> Callback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNode", "ListenForKeyAction");

	Params::ScenarioStateNode_ListenForKeyAction Parms{};

	Parms.InKey = std::move(InKey);
	Parms.EventType = EventType;
	Parms.bConsume = bConsume;
	Parms.Callback = Callback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateNode.OnEditorShowElementPlayFinish
// (Final, Native, Public)

void UScenarioStateNode::OnEditorShowElementPlayFinish()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNode", "OnEditorShowElementPlayFinish");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateNode.OnInitCameraSequenceFinished
// (Event, Public, BlueprintEvent)

void UScenarioStateNode::OnInitCameraSequenceFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNode", "OnInitCameraSequenceFinished");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharacterInteractionV3.ScenarioStateNode.OnLookAround
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScenarioStateNode::OnLookAround(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNode", "OnLookAround");

	Params::ScenarioStateNode_OnLookAround Parms{};

	Parms.InValue = InValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharacterInteractionV3.ScenarioStateNode.OnLookUp
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScenarioStateNode::OnLookUp(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNode", "OnLookUp");

	Params::ScenarioStateNode_OnLookUp Parms{};

	Parms.InValue = InValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharacterInteractionV3.ScenarioStateNode.OnMoveForward
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScenarioStateNode::OnMoveForward(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNode", "OnMoveForward");

	Params::ScenarioStateNode_OnMoveForward Parms{};

	Parms.InValue = InValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharacterInteractionV3.ScenarioStateNode.OnMoveRight
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScenarioStateNode::OnMoveRight(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNode", "OnMoveRight");

	Params::ScenarioStateNode_OnMoveRight Parms{};

	Parms.InValue = InValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharacterInteractionV3.ScenarioStateNode.PlayShowElement
// (Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    ElementName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    NextState                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEndLastShowElement                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScenarioStateNode::PlayShowElement(const class FString& ElementName, const class FString& NextState, bool bEndLastShowElement)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNode", "PlayShowElement");

	Params::ScenarioStateNode_PlayShowElement Parms{};

	Parms.ElementName = std::move(ElementName);
	Parms.NextState = std::move(NextState);
	Parms.bEndLastShowElement = bEndLastShowElement;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateNode.PlayShowElementByCallback
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    InElement                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    NextState                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       OnShowElementPlayFinish                                (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bEndLastShowElement                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScenarioStateNode::PlayShowElementByCallback(const class FString& InElement, const class FString& NextState, TDelegate<void()> OnShowElementPlayFinish, bool bEndLastShowElement)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNode", "PlayShowElementByCallback");

	Params::ScenarioStateNode_PlayShowElementByCallback Parms{};

	Parms.InElement = std::move(InElement);
	Parms.NextState = std::move(NextState);
	Parms.OnShowElementPlayFinish = OnShowElementPlayFinish;
	Parms.bEndLastShowElement = bEndLastShowElement;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateNode.PlayShowElementByCallbackWithCameraBlend
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    InElement                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    NextState                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       OnShowElementPlayFinish                                (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bEndLastShowElement                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInForceCameraBlend                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScenarioStateNode::PlayShowElementByCallbackWithCameraBlend(const class FString& InElement, const class FString& NextState, TDelegate<void()> OnShowElementPlayFinish, bool bEndLastShowElement, bool bInForceCameraBlend)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNode", "PlayShowElementByCallbackWithCameraBlend");

	Params::ScenarioStateNode_PlayShowElementByCallbackWithCameraBlend Parms{};

	Parms.InElement = std::move(InElement);
	Parms.NextState = std::move(NextState);
	Parms.OnShowElementPlayFinish = OnShowElementPlayFinish;
	Parms.bEndLastShowElement = bEndLastShowElement;
	Parms.bInForceCameraBlend = bInForceCameraBlend;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateNode.PlayShowElementList
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<class FString>&            InElements                                             (ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// const class FString&                    NextState                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEndLastShowElement                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScenarioStateNode::PlayShowElementList(const TArray<class FString>& InElements, const class FString& NextState, bool bEndLastShowElement)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNode", "PlayShowElementList");

	Params::ScenarioStateNode_PlayShowElementList Parms{};

	Parms.InElements = std::move(InElements);
	Parms.NextState = std::move(NextState);
	Parms.bEndLastShowElement = bEndLastShowElement;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateNode.PlayShowElementListByCallback
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<class FString>&            InElements                                             (ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// const class FString&                    NextState                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       OnShowElementPlayFinish                                (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bEndLastShowElement                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScenarioStateNode::PlayShowElementListByCallback(const TArray<class FString>& InElements, const class FString& NextState, TDelegate<void()> OnShowElementPlayFinish, bool bEndLastShowElement)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNode", "PlayShowElementListByCallback");

	Params::ScenarioStateNode_PlayShowElementListByCallback Parms{};

	Parms.InElements = std::move(InElements);
	Parms.NextState = std::move(NextState);
	Parms.OnShowElementPlayFinish = OnShowElementPlayFinish;
	Parms.bEndLastShowElement = bEndLastShowElement;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateNode.PlayStandBy
// (Native, Public, BlueprintCallable)

void UScenarioStateNode::PlayStandBy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNode", "PlayStandBy");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateNode.RemoveAllAddHolyLightData
// (Final, Native, Public, BlueprintCallable)

void UScenarioStateNode::RemoveAllAddHolyLightData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNode", "RemoveAllAddHolyLightData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateNode.RemoveFromExecutableOperates
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<class UInteractionOperateV3*>&InOperates                                             (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UScenarioStateNode::RemoveFromExecutableOperates(const TArray<class UInteractionOperateV3*>& InOperates)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNode", "RemoveFromExecutableOperates");

	Params::ScenarioStateNode_RemoveFromExecutableOperates Parms{};

	Parms.InOperates = std::move(InOperates);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateNode.SetNodeInnerState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const EScenarioNodeInnerState           InNewState                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScenarioStateNode::SetNodeInnerState(const EScenarioNodeInnerState InNewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNode", "SetNodeInnerState");

	Params::ScenarioStateNode_SetNodeInnerState Parms{};

	Parms.InNewState = InNewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateNode.StopAllListenForKeyAction
// (Final, Native, Public, BlueprintCallable)

void UScenarioStateNode::StopAllListenForKeyAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNode", "StopAllListenForKeyAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateNode.StopAllListeningForHandle
// (Final, Native, Public, BlueprintCallable)

void UScenarioStateNode::StopAllListeningForHandle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNode", "StopAllListeningForHandle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateNode.StopListenForKeyAction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FKey&                      InKey                                                  (ConstParm, Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputEvent                             EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScenarioStateNode::StopListenForKeyAction(const struct FKey& InKey, EInputEvent EventType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNode", "StopListenForKeyAction");

	Params::ScenarioStateNode_StopListenForKeyAction Parms{};

	Parms.InKey = std::move(InKey);
	Parms.EventType = EventType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateNode.StopListeningForHandle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InHandle                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScenarioStateNode::StopListeningForHandle(int32 InHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNode", "StopListeningForHandle");

	Params::ScenarioStateNode_StopListeningForHandle Parms{};

	Parms.InHandle = InHandle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateNode.StopListeningForInputAction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ActionName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputEvent                             EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScenarioStateNode::StopListeningForInputAction(class FName ActionName, EInputEvent EventType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNode", "StopListeningForInputAction");

	Params::ScenarioStateNode_StopListeningForInputAction Parms{};

	Parms.ActionName = ActionName;
	Parms.EventType = EventType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateNode.UpdateHolyLightData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<struct FInteractionV3CharacterHolyLight>&InDatas                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const bool                              bAdd                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    InReason                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScenarioStateNode::UpdateHolyLightData(const TArray<struct FInteractionV3CharacterHolyLight>& InDatas, const bool bAdd, const class FString& InReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNode", "UpdateHolyLightData");

	Params::ScenarioStateNode_UpdateHolyLightData Parms{};

	Parms.InDatas = std::move(InDatas);
	Parms.bAdd = bAdd;
	Parms.InReason = std::move(InReason);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateNode.UpdateOperateHolyLightData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UScenarioOperate*                 InScenarioOperate                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bAdd                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScenarioStateNode::UpdateOperateHolyLightData(class UScenarioOperate* InScenarioOperate, const bool bAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNode", "UpdateOperateHolyLightData");

	Params::ScenarioStateNode_UpdateOperateHolyLightData Parms{};

	Parms.InScenarioOperate = InScenarioOperate;
	Parms.bAdd = bAdd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateNode.UpdateShowElementHolyLightData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    InShowElementName                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bAdd                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScenarioStateNode::UpdateShowElementHolyLightData(const class FString& InShowElementName, const bool bAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNode", "UpdateShowElementHolyLightData");

	Params::ScenarioStateNode_UpdateShowElementHolyLightData Parms{};

	Parms.InShowElementName = std::move(InShowElementName);
	Parms.bAdd = bAdd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateNode.UpdateStandbyHolyLightData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              bAdd                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScenarioStateNode::UpdateStandbyHolyLightData(const bool bAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNode", "UpdateStandbyHolyLightData");

	Params::ScenarioStateNode_UpdateStandbyHolyLightData Parms{};

	Parms.bAdd = bAdd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateNode.GetNodeInnerState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EScenarioNodeInnerState                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EScenarioNodeInnerState UScenarioStateNode::GetNodeInnerState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNode", "GetNodeInnerState");

	Params::ScenarioStateNode_GetNodeInnerState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ScenarioStateNode.GetOperateScenarioOperate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UScenarioOperate*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UScenarioOperate* UScenarioStateNode::GetOperateScenarioOperate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNode", "GetOperateScenarioOperate");

	Params::ScenarioStateNode_GetOperateScenarioOperate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ScenarioStateNode.GetPressedCollision
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInteractionV3InputCollision*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractionV3InputCollision* UScenarioStateNode::GetPressedCollision() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNode", "GetPressedCollision");

	Params::ScenarioStateNode_GetPressedCollision Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ScenarioStateNode.GetSelectedCollision
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInteractionV3InputCollision*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractionV3InputCollision* UScenarioStateNode::GetSelectedCollision() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNode", "GetSelectedCollision");

	Params::ScenarioStateNode_GetSelectedCollision Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ScenarioStateNode.GetShowElementPlayTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UScenarioStateNode::GetShowElementPlayTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNode", "GetShowElementPlayTime");

	Params::ScenarioStateNode_GetShowElementPlayTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ScenarioStateNode.GetShowElementRemainingTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UScenarioStateNode::GetShowElementRemainingTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNode", "GetShowElementRemainingTime");

	Params::ScenarioStateNode_GetShowElementRemainingTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ScenarioStateNode.GetStandbyCameraIDs
// (Final, Native, Public, Const)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UScenarioStateNode::GetStandbyCameraIDs() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNode", "GetStandbyCameraIDs");

	Params::ScenarioStateNode_GetStandbyCameraIDs Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ScenarioStateNode.IsBlockInput
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UScenarioStateNode::IsBlockInput() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNode", "IsBlockInput");

	Params::ScenarioStateNode_IsBlockInput Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ScenarioStateNode.SetCameraPosition
// (Native, Public, BlueprintCallable, Const)

void UScenarioStateNode::SetCameraPosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNode", "SetCameraPosition");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateNode.TryFixCameraPos
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// const bool                              bForceUpdate                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScenarioStateNode::TryFixCameraPos(const bool bForceUpdate) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNode", "TryFixCameraPos");

	Params::ScenarioStateNode_TryFixCameraPos Parms{};

	Parms.bForceUpdate = bForceUpdate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateNode_Confession.SetConfessionState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const EConfessionInnerState             NewState                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScenarioStateNode_Confession::SetConfessionState(const EConfessionInnerState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNode_Confession", "SetConfessionState");

	Params::ScenarioStateNode_Confession_SetConfessionState Parms{};

	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateNode_Confession.GetConfessionState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EConfessionInnerState                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EConfessionInnerState UScenarioStateNode_Confession::GetConfessionState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNode_Confession", "GetConfessionState");

	Params::ScenarioStateNode_Confession_GetConfessionState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ScenarioStateNode_Confession.IsAutoPlay
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UScenarioStateNode_Confession::IsAutoPlay() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNode_Confession", "IsAutoPlay");

	Params::ScenarioStateNode_Confession_IsAutoPlay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ScenarioStateNode_Confession.IsEndNode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UScenarioStateNode_Confession::IsEndNode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNode_Confession", "IsEndNode");

	Params::ScenarioStateNode_Confession_IsEndNode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ScenarioStateNode_ConfessionEntry.OnInitShowElementFinish
// (Final, Native, Protected)

void UScenarioStateNode_ConfessionEntry::OnInitShowElementFinish()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNode_ConfessionEntry", "OnInitShowElementFinish");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ScenarioStateNode_LittleGame.GetLittleGameInstance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UScenarioStandardLittleGame*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UScenarioStandardLittleGame* UScenarioStateNode_LittleGame::GetLittleGameInstance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioStateNode_LittleGame", "GetLittleGameInstance");

	Params::ScenarioStateNode_LittleGame_GetLittleGameInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ShowElementV3.GetDurationTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UShowElementV3::GetDurationTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShowElementV3", "GetDurationTime");

	Params::ShowElementV3_GetDurationTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ShowElementV3.GetShowElementHolyLight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<struct FInteractionV3CharacterHolyLight>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FInteractionV3CharacterHolyLight> UShowElementV3::GetShowElementHolyLight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShowElementV3", "GetShowElementHolyLight");

	Params::ShowElementV3_GetShowElementHolyLight Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteractionV3.ShowElementV3UnitPlayer.EndUnit
// (Native, Event, Public, BlueprintEvent)

void UShowElementV3UnitPlayer::EndUnit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShowElementV3UnitPlayer", "EndUnit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ShowElementV3UnitPlayer.OnInitializePlayer
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AInteractionActorV3*              Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShowElementV3UnitPlayer::OnInitializePlayer(class AInteractionActorV3* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShowElementV3UnitPlayer", "OnInitializePlayer");

	Params::ShowElementV3UnitPlayer_OnInitializePlayer Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ShowElementV3UnitPlayer.PlayUnit
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// const class UShowElementV3Unit*         Unit                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShowElementV3UnitPlayer::PlayUnit(const class UShowElementV3Unit* Unit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShowElementV3UnitPlayer", "PlayUnit");

	Params::ShowElementV3UnitPlayer_PlayUnit Parms{};

	Parms.Unit = Unit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ShowElementV3UnitPlayer.QuitUnit
// (Native, Event, Public, BlueprintEvent)

void UShowElementV3UnitPlayer::QuitUnit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShowElementV3UnitPlayer", "QuitUnit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteractionV3.ShowElementV3UnitPlayer.TickUnit
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShowElementV3UnitPlayer::TickUnit(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShowElementV3UnitPlayer", "TickUnit");

	Params::ShowElementV3UnitPlayer_TickUnit Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}

