#pragma once

/*
* SDK generated by Rei-SdkDumper
* Based on Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: CharacterInteraction

#include "Basic.hpp"

#include "CharacterInteraction_classes.hpp"
#include "CharacterInteraction_parameters.hpp"


namespace SDK
{

// Function CharacterInteraction.InteractionArchivementComponent.GetEggLevelSeqs
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class ULevelSequence*>*          OutLevelSeqs                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UInteractionArchivementComponent::GetEggLevelSeqs(TArray<class ULevelSequence*>* OutLevelSeqs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionArchivementComponent", "GetEggLevelSeqs");

	Params::InteractionArchivementComponent_GetEggLevelSeqs Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLevelSeqs != nullptr)
		*OutLevelSeqs = std::move(Parms.OutLevelSeqs);
}


// Function CharacterInteraction.InteractionArchivementComponent.SetArchievementPlayed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionArchivementComponent::SetArchievementPlayed(int32 ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionArchivementComponent", "SetArchievementPlayed");

	Params::InteractionArchivementComponent_SetArchievementPlayed Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionArchivementComponent.SetArchivementComplete
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionArchivementComponent::SetArchivementComplete(int32 ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionArchivementComponent", "SetArchivementComplete");

	Params::InteractionArchivementComponent_SetArchivementComplete Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionArchivementComponent.SetConditionComplete
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionArchivementComponent::SetConditionComplete(int32 ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionArchivementComponent", "SetConditionComplete");

	Params::InteractionArchivementComponent_SetConditionComplete Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionArchivementComponent.SetConditionCompleteAdnRefresh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionArchivementComponent::SetConditionCompleteAdnRefresh(int32 ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionArchivementComponent", "SetConditionCompleteAdnRefresh");

	Params::InteractionArchivementComponent_SetConditionCompleteAdnRefresh Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionArchivementComponent.IsArchivementComplete
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionArchivementComponent::IsArchivementComplete(int32 ID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionArchivementComponent", "IsArchivementComplete");

	Params::InteractionArchivementComponent_IsArchivementComplete Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteraction.InteractionArchivementComponent.IsArchivementPlayed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionArchivementComponent::IsArchivementPlayed(int32 ID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionArchivementComponent", "IsArchivementPlayed");

	Params::InteractionArchivementComponent_IsArchivementPlayed Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteraction.InteractionArchivementComponent.IsConditionComplete
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionArchivementComponent::IsConditionComplete(int32 ID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionArchivementComponent", "IsConditionComplete");

	Params::InteractionArchivementComponent_IsConditionComplete Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteraction.CharacterInteractionComponent.GetInteractionAnimInstance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UInteractionAnimInstance*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractionAnimInstance* UCharacterInteractionComponent::GetInteractionAnimInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInteractionComponent", "GetInteractionAnimInstance");

	Params::CharacterInteractionComponent_GetInteractionAnimInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteraction.CharacterInteractionComponent.GetInteractionHeadAnimInstance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UInteractionHeadAnimInstance*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractionHeadAnimInstance* UCharacterInteractionComponent::GetInteractionHeadAnimInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInteractionComponent", "GetInteractionHeadAnimInstance");

	Params::CharacterInteractionComponent_GetInteractionHeadAnimInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteraction.CharacterInteractionComponent.OnPropsInteractionEnd
// (Final, Native, Public, BlueprintCallable)

void UCharacterInteractionComponent::OnPropsInteractionEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInteractionComponent", "OnPropsInteractionEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.CharacterInteractionComponent.PlayShowSequence
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ShowSequenceID                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterInteractionComponent::PlayShowSequence(int32 ShowSequenceID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInteractionComponent", "PlayShowSequence");

	Params::CharacterInteractionComponent_PlayShowSequence Parms{};

	Parms.ShowSequenceID = ShowSequenceID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.CharacterInteractionComponent.PlayWeightedVoice
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<struct FWeightedVoice>&    VoiceIDs                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterInteractionComponent::PlayWeightedVoice(const TArray<struct FWeightedVoice>& VoiceIDs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInteractionComponent", "PlayWeightedVoice");

	Params::CharacterInteractionComponent_PlayWeightedVoice Parms{};

	Parms.VoiceIDs = std::move(VoiceIDs);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.CharacterInteractionComponent.ResetInteraction
// (Final, Native, Public, BlueprintCallable)

void UCharacterInteractionComponent::ResetInteraction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInteractionComponent", "ResetInteraction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.CharacterInteractionComponent.SetbIsPlayingAnim
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsPlaying                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterInteractionComponent::SetbIsPlayingAnim(bool bIsPlaying)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInteractionComponent", "SetbIsPlayingAnim");

	Params::CharacterInteractionComponent_SetbIsPlayingAnim Parms{};

	Parms.bIsPlaying = bIsPlaying;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.CharacterInteractionComponent.SetExplicitForbitEyeFollow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInExplicitForbit                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterInteractionComponent::SetExplicitForbitEyeFollow(bool bInExplicitForbit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInteractionComponent", "SetExplicitForbitEyeFollow");

	Params::CharacterInteractionComponent_SetExplicitForbitEyeFollow Parms{};

	Parms.bInExplicitForbit = bInExplicitForbit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.CharacterInteractionComponent.SetFinishedInteractionTutorial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsFinished                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterInteractionComponent::SetFinishedInteractionTutorial(bool IsFinished)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInteractionComponent", "SetFinishedInteractionTutorial");

	Params::CharacterInteractionComponent_SetFinishedInteractionTutorial Parms{};

	Parms.IsFinished = IsFinished;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.CharacterInteractionComponent.SetIsInteractionInterface
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NewBool                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterInteractionComponent::SetIsInteractionInterface(bool NewBool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInteractionComponent", "SetIsInteractionInterface");

	Params::CharacterInteractionComponent_SetIsInteractionInterface Parms{};

	Parms.NewBool = NewBool;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.CharacterInteractionComponent.SetOperateEyeFollow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEyeFollow                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterInteractionComponent::SetOperateEyeFollow(bool bEyeFollow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInteractionComponent", "SetOperateEyeFollow");

	Params::CharacterInteractionComponent_SetOperateEyeFollow Parms{};

	Parms.bEyeFollow = bEyeFollow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.CharacterInteractionComponent.StartStandby
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   StandByID                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterInteractionComponent::StartStandby(int32 StandByID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInteractionComponent", "StartStandby");

	Params::CharacterInteractionComponent_StartStandby Parms{};

	Parms.StandByID = StandByID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.CharacterInteractionComponent.UpdateKawaii
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewBlendCounter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    NewShutDownKawaii                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterInteractionComponent::UpdateKawaii(float NewBlendCounter, bool NewShutDownKawaii)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInteractionComponent", "UpdateKawaii");

	Params::CharacterInteractionComponent_UpdateKawaii Parms{};

	Parms.NewBlendCounter = NewBlendCounter;
	Parms.NewShutDownKawaii = NewShutDownKawaii;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.CharacterInteractionComponent.GetIsInteractionInterface
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterInteractionComponent::GetIsInteractionInterface() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInteractionComponent", "GetIsInteractionInterface");

	Params::CharacterInteractionComponent_GetIsInteractionInterface Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteraction.CharacterInteractionComponent.GetKawaiiAlphaValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCharacterInteractionComponent::GetKawaiiAlphaValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInteractionComponent", "GetKawaiiAlphaValue");

	Params::CharacterInteractionComponent_GetKawaiiAlphaValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteraction.FlowerMouseOverInterface.OnMouseOver
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector2D&                 OverDistance                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector2D&                 TargetPosition                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector2D&                 LastMousePos                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IFlowerMouseOverInterface::OnMouseOver(const struct FVector2D& OverDistance, const struct FVector2D& TargetPosition, const struct FVector2D& LastMousePos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("FlowerMouseOverInterface", "OnMouseOver");

	Params::FlowerMouseOverInterface_OnMouseOver Parms{};

	Parms.OverDistance = std::move(OverDistance);
	Parms.TargetPosition = std::move(TargetPosition);
	Parms.LastMousePos = std::move(LastMousePos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionOperate.OnInteractionEnd
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AInteractionCharacter*            Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionOperate::OnInteractionEnd(class AInteractionCharacter* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionOperate", "OnInteractionEnd");

	Params::InteractionOperate_OnInteractionEnd Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionOperate.OnInteractionRemove
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AInteractionCharacter*            Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionOperate::OnInteractionRemove(class AInteractionCharacter* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionOperate", "OnInteractionRemove");

	Params::InteractionOperate_OnInteractionRemove Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionOperate.OnInteractionReuse
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AInteractionCharacter*            Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionOperate::OnInteractionReuse(class AInteractionCharacter* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionOperate", "OnInteractionReuse");

	Params::InteractionOperate_OnInteractionReuse Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionOperate.OnInteractionStart
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AInteractionCharacter*            Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionOperate::OnInteractionStart(class AInteractionCharacter* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionOperate", "OnInteractionStart");

	Params::InteractionOperate_OnInteractionStart Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionOperate.OnInteractionUpdate
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AInteractionCharacter*            Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionOperate::OnInteractionUpdate(class AInteractionCharacter* Actor, float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionOperate", "OnInteractionUpdate");

	Params::InteractionOperate_OnInteractionUpdate Parms{};

	Parms.Actor = Actor;
	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionOperate.OnScenarioChange
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// int32                                   ScenarioID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionOperate::OnScenarioChange(int32 ScenarioID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionOperate", "OnScenarioChange");

	Params::InteractionOperate_OnScenarioChange Parms{};

	Parms.ScenarioID = ScenarioID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionOperate.OnStandByChange
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// int32                                   ScenarioID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionOperate::OnStandByChange(int32 ScenarioID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionOperate", "OnStandByChange");

	Params::InteractionOperate_OnStandByChange Parms{};

	Parms.ScenarioID = ScenarioID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionOperate.SetIsStop
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInStop                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionOperate::SetIsStop(bool bInStop)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionOperate", "SetIsStop");

	Params::InteractionOperate_SetIsStop Parms{};

	Parms.bInStop = bInStop;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionOperate.ShouldRemove
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AInteractionCharacter*            Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionOperate::ShouldRemove(class AInteractionCharacter* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionOperate", "ShouldRemove");

	Params::InteractionOperate_ShouldRemove Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteraction.InteractionOperate.GetIsStop
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionOperate::GetIsStop() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionOperate", "GetIsStop");

	Params::InteractionOperate_GetIsStop Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteraction.InteractionOperate.IsBlockOperate
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionOperate::IsBlockOperate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionOperate", "IsBlockOperate");

	Params::InteractionOperate_IsBlockOperate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteraction.InteractionOperate.OnInteractionResume
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class AInteractionCharacter*            Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionOperate::OnInteractionResume(class AInteractionCharacter* Actor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionOperate", "OnInteractionResume");

	Params::InteractionOperate_OnInteractionResume Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionOperate.OnInteractionStop
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class AInteractionCharacter*            Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionOperate::OnInteractionStop(class AInteractionCharacter* Actor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionOperate", "OnInteractionStop");

	Params::InteractionOperate_OnInteractionStop Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionOperate.ShouldStopOnRelease
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionOperate::ShouldStopOnRelease() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionOperate", "ShouldStopOnRelease");

	Params::InteractionOperate_ShouldStopOnRelease Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteraction.DragInteraction.UpdateDrag
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class AInteractionCharacter*            Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaSecond                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragInteraction::UpdateDrag(class AInteractionCharacter* Actor, float DeltaSecond)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragInteraction", "UpdateDrag");

	Params::DragInteraction_UpdateDrag Parms{};

	Parms.Actor = Actor;
	Parms.DeltaSecond = DeltaSecond;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.DragInteraction.UpdateRecover
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class AInteractionCharacter*            Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragInteraction::UpdateRecover(class AInteractionCharacter* Actor, float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragInteraction", "UpdateRecover");

	Params::DragInteraction_UpdateRecover Parms{};

	Parms.Actor = Actor;
	Parms.DeltaSeconds = DeltaSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.PropsUpdateInterface.PropsUpdate
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FTransform&                NewTransform                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void IPropsUpdateInterface::PropsUpdate(const struct FTransform& NewTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("PropsUpdateInterface", "PropsUpdate");

	Params::PropsUpdateInterface_PropsUpdate Parms{};

	Parms.NewTransform = std::move(NewTransform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.PropsClickedInterface.PropsClicked
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IPropsClickedInterface::PropsClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("PropsClickedInterface", "PropsClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionPropsDrag.ReSetCurrentEnergy
// (Final, Native, Protected, BlueprintCallable)

void UInteractionPropsDrag::ReSetCurrentEnergy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionPropsDrag", "ReSetCurrentEnergy");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionAnimInstance.ScenarioInitializeAnimation
// (Final, Native, Public, BlueprintCallable)

void UInteractionAnimInstance::ScenarioInitializeAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionAnimInstance", "ScenarioInitializeAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionAnimInstance.SetIsDebugDraw
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInDebugDraw                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionAnimInstance::SetIsDebugDraw(bool bInDebugDraw)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionAnimInstance", "SetIsDebugDraw");

	Params::InteractionAnimInstance_SetIsDebugDraw Parms{};

	Parms.bInDebugDraw = bInDebugDraw;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionAnimInstance.GetIsDebugDraw
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionAnimInstance::GetIsDebugDraw() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionAnimInstance", "GetIsDebugDraw");

	Params::InteractionAnimInstance_GetIsDebugDraw Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteraction.InteractionCableComponent.AddConstraint
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   IndexA                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   IndexB                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionCableComponent::AddConstraint(int32 IndexA, int32 IndexB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionCableComponent", "AddConstraint");

	Params::InteractionCableComponent_AddConstraint Parms{};

	Parms.IndexA = IndexA;
	Parms.IndexB = IndexB;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionCableComponent.GrabParticles
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const int32                             ParticleIndex                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   DragForce                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionCableComponent::GrabParticles(const int32 ParticleIndex, const struct FVector& DragForce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionCableComponent", "GrabParticles");

	Params::InteractionCableComponent_GrabParticles Parms{};

	Parms.ParticleIndex = ParticleIndex;
	Parms.DragForce = std::move(DragForce);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionCableComponent.IntegrateParticles
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionCableComponent::IntegrateParticles(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionCableComponent", "IntegrateParticles");

	Params::InteractionCableComponent_IntegrateParticles Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionCableComponent.SetAttachEndTo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ComponentProperty                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SocketName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionCableComponent::SetAttachEndTo(class AActor* Actor, class FName ComponentProperty, class FName SocketName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionCableComponent", "SetAttachEndTo");

	Params::InteractionCableComponent_SetAttachEndTo Parms{};

	Parms.Actor = Actor;
	Parms.ComponentProperty = ComponentProperty;
	Parms.SocketName = SocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionCableComponent.SetAttachEndToComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SocketName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionCableComponent::SetAttachEndToComponent(class USceneComponent* Component, class FName SocketName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionCableComponent", "SetAttachEndToComponent");

	Params::InteractionCableComponent_SetAttachEndToComponent Parms{};

	Parms.Component = Component;
	Parms.SocketName = SocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionCableComponent.SolveDistanceConstraints
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionCableComponent::SolveDistanceConstraints(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionCableComponent", "SolveDistanceConstraints");

	Params::InteractionCableComponent_SolveDistanceConstraints Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionCableComponent.UpdateVelocities
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionCableComponent::UpdateVelocities(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionCableComponent", "UpdateVelocities");

	Params::InteractionCableComponent_UpdateVelocities Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionCableComponent.DebugDraw
// (Final, Native, Public, BlueprintCallable, Const)

void UInteractionCableComponent::DebugDraw() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionCableComponent", "DebugDraw");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionCableComponent.GetAttachedActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UInteractionCableComponent::GetAttachedActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionCableComponent", "GetAttachedActor");

	Params::InteractionCableComponent_GetAttachedActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteraction.InteractionCableComponent.GetAttachedComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USceneComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USceneComponent* UInteractionCableComponent::GetAttachedComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionCableComponent", "GetAttachedComponent");

	Params::InteractionCableComponent_GetAttachedComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteraction.InteractionCableComponent.GetInteractionCableParticleLocations
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FVector>*                 Locations                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UInteractionCableComponent::GetInteractionCableParticleLocations(TArray<struct FVector>* Locations) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionCableComponent", "GetInteractionCableParticleLocations");

	Params::InteractionCableComponent_GetInteractionCableParticleLocations Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Locations != nullptr)
		*Locations = std::move(Parms.Locations);
}


// Function CharacterInteraction.InteractionCharacter.BlendPhysics
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   TimelineLength                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractionCharacter::BlendPhysics(float TimelineLength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionCharacter", "BlendPhysics");

	Params::InteractionCharacter_BlendPhysics Parms{};

	Parms.TimelineLength = TimelineLength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionCharacter.GetStandByConfig
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   StandByID                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FInteractionStandByConfig*       Config                                                 (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AInteractionCharacter::GetStandByConfig(int32 StandByID, struct FInteractionStandByConfig* Config)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionCharacter", "GetStandByConfig");

	Params::InteractionCharacter_GetStandByConfig Parms{};

	Parms.StandByID = StandByID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Config != nullptr)
		*Config = std::move(Parms.Config);

	return Parms.ReturnValue;
}


// Function CharacterInteraction.InteractionCharacter.InteractionStartBlush
// (Event, Public, BlueprintEvent)

void AInteractionCharacter::InteractionStartBlush()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionCharacter", "InteractionStartBlush");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharacterInteraction.InteractionCharacter.InteractionStopBlush
// (Event, Public, BlueprintEvent)

void AInteractionCharacter::InteractionStopBlush()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionCharacter", "InteractionStopBlush");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CharacterInteraction.InteractionCharacter.OnLipSyncDataReady
// (Final, Native, Private)

void AInteractionCharacter::OnLipSyncDataReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionCharacter", "OnLipSyncDataReady");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionCharacter.SetPhysicsBlendWeight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             SetName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartBlend                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendSpeed                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    CompleteClose                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractionCharacter::SetPhysicsBlendWeight(class FName SetName, float StartBlend, float Target, float BlendSpeed, bool CompleteClose)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionCharacter", "SetPhysicsBlendWeight");

	Params::InteractionCharacter_SetPhysicsBlendWeight Parms{};

	Parms.SetName = SetName;
	Parms.StartBlend = StartBlend;
	Parms.Target = Target;
	Parms.BlendSpeed = BlendSpeed;
	Parms.CompleteClose = CompleteClose;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionCharacter.SetReceiveInteraction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInReceive                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractionCharacter::SetReceiveInteraction(bool bInReceive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionCharacter", "SetReceiveInteraction");

	Params::InteractionCharacter_SetReceiveInteraction Parms{};

	Parms.bInReceive = bInReceive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionCharacter.GetBodyComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* AInteractionCharacter::GetBodyComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionCharacter", "GetBodyComponent");

	Params::InteractionCharacter_GetBodyComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteraction.InteractionCharacter.GetHeadComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* AInteractionCharacter::GetHeadComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionCharacter", "GetHeadComponent");

	Params::InteractionCharacter_GetHeadComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteraction.InteractionCharacter.GetInteractionName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName AInteractionCharacter::GetInteractionName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionCharacter", "GetInteractionName");

	Params::InteractionCharacter_GetInteractionName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteraction.InteractionCharacter.GetIsDebugDraw
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AInteractionCharacter::GetIsDebugDraw() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionCharacter", "GetIsDebugDraw");

	Params::InteractionCharacter_GetIsDebugDraw Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteraction.InteractionCharacter.GetReceiveInteraction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AInteractionCharacter::GetReceiveInteraction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionCharacter", "GetReceiveInteraction");

	Params::InteractionCharacter_GetReceiveInteraction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteraction.InteractionCharacter.GetSkinID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AInteractionCharacter::GetSkinID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionCharacter", "GetSkinID");

	Params::InteractionCharacter_GetSkinID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteraction.InteractionExtraSequenceProcessor.OnSequenceBegin
// (Native, Event, Public, BlueprintEvent)

void UInteractionExtraSequenceProcessor::OnSequenceBegin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionExtraSequenceProcessor", "OnSequenceBegin");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionExtraSequenceProcessor.OnSequenceEnd
// (Native, Event, Public, BlueprintEvent)

void UInteractionExtraSequenceProcessor::OnSequenceEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionExtraSequenceProcessor", "OnSequenceEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionExtraSequenceProcessor.OnTickSequence
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionExtraSequenceProcessor::OnTickSequence(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionExtraSequenceProcessor", "OnTickSequence");

	Params::InteractionExtraSequenceProcessor_OnTickSequence Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionExtraStandByProcessor.OnMenuEvent
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// int32                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionExtraStandByProcessor::OnMenuEvent(int32 ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionExtraStandByProcessor", "OnMenuEvent");

	Params::InteractionExtraStandByProcessor_OnMenuEvent Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionExtraStandByProcessor.OnStandByBegin
// (Native, Event, Public, BlueprintEvent)

void UInteractionExtraStandByProcessor::OnStandByBegin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionExtraStandByProcessor", "OnStandByBegin");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionExtraStandByProcessor.OnStandByEnd
// (Native, Event, Public, BlueprintEvent)

void UInteractionExtraStandByProcessor::OnStandByEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionExtraStandByProcessor", "OnStandByEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionExtraStandByProcessor.OnTickStandBy
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionExtraStandByProcessor::OnTickStandBy(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionExtraStandByProcessor", "OnTickStandBy");

	Params::InteractionExtraStandByProcessor_OnTickStandBy Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionDirector.GetInteractionDirector
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AInteractionDirector*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AInteractionDirector* AInteractionDirector::GetInteractionDirector(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InteractionDirector", "GetInteractionDirector");

	Params::InteractionDirector_GetInteractionDirector Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteraction.InteractionDirector.CreateInteractionCharacter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AInteractionCharacter>Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InteractionCharacterName                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AInteractionCharacter*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AInteractionCharacter* AInteractionDirector::CreateInteractionCharacter(TSubclassOf<class AInteractionCharacter> Type, class FName InteractionCharacterName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDirector", "CreateInteractionCharacter");

	Params::InteractionDirector_CreateInteractionCharacter Parms{};

	Parms.Type = Type;
	Parms.InteractionCharacterName = InteractionCharacterName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteraction.InteractionDirector.GetCollisionEventData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FInteractionCollisionEventDataReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FInteractionCollisionEventData AInteractionDirector::GetCollisionEventData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDirector", "GetCollisionEventData");

	Params::InteractionDirector_GetCollisionEventData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteraction.InteractionDirector.GetLittleGameComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UInteractionLittleGameComponent*  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractionLittleGameComponent* AInteractionDirector::GetLittleGameComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDirector", "GetLittleGameComponent");

	Params::InteractionDirector_GetLittleGameComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteraction.InteractionDirector.GetMousePosition
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D AInteractionDirector::GetMousePosition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDirector", "GetMousePosition");

	Params::InteractionDirector_GetMousePosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteraction.InteractionDirector.GetMousePressPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D AInteractionDirector::GetMousePressPosition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDirector", "GetMousePressPosition");

	Params::InteractionDirector_GetMousePressPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteraction.InteractionDirector.HaveLittleGame
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AInteractionDirector::HaveLittleGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDirector", "HaveLittleGame");

	Params::InteractionDirector_HaveLittleGame Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteraction.InteractionDirector.RemoveInteractionCharacter
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      Name_0                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractionDirector::RemoveInteractionCharacter(const class FName& Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDirector", "RemoveInteractionCharacter");

	Params::InteractionDirector_RemoveInteractionCharacter Parms{};

	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionDirector.SetIsInLittleGame
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsInGame                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractionDirector::SetIsInLittleGame(bool bIsInGame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDirector", "SetIsInLittleGame");

	Params::InteractionDirector_SetIsInLittleGame Parms{};

	Parms.bIsInGame = bIsInGame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionDirector.SetIsMouseInScreen
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInIsMouseInScreen                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractionDirector::SetIsMouseInScreen(bool bInIsMouseInScreen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDirector", "SetIsMouseInScreen");

	Params::InteractionDirector_SetIsMouseInScreen Parms{};

	Parms.bInIsMouseInScreen = bInIsMouseInScreen;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionDirector.SetIsMousePressed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInIsMousePressed                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractionDirector::SetIsMousePressed(bool bInIsMousePressed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDirector", "SetIsMousePressed");

	Params::InteractionDirector_SetIsMousePressed Parms{};

	Parms.bInIsMousePressed = bInIsMousePressed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionDirector.SetMousePosition
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector2D&                 Pos                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractionDirector::SetMousePosition(const struct FVector2D& Pos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDirector", "SetMousePosition");

	Params::InteractionDirector_SetMousePosition Parms{};

	Parms.Pos = std::move(Pos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionDirector.SetMousePressPosition
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector2D&                 Pos                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractionDirector::SetMousePressPosition(const struct FVector2D& Pos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDirector", "SetMousePressPosition");

	Params::InteractionDirector_SetMousePressPosition Parms{};

	Parms.Pos = std::move(Pos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionDirector.StartLittleGame
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractionDirector::StartLittleGame(int32 ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDirector", "StartLittleGame");

	Params::InteractionDirector_StartLittleGame Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionDirector.StopLittleGame
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsVictory                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractionDirector::StopLittleGame(bool bIsVictory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDirector", "StopLittleGame");

	Params::InteractionDirector_StopLittleGame Parms{};

	Parms.bIsVictory = bIsVictory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionDirector.GetAllInteractionCharacters
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TMap<class FName, class AInteractionCharacter*>ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<class FName, class AInteractionCharacter*> AInteractionDirector::GetAllInteractionCharacters() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDirector", "GetAllInteractionCharacters");

	Params::InteractionDirector_GetAllInteractionCharacters Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteraction.InteractionDirector.GetArchivementComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInteractionArchivementComponent* ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractionArchivementComponent* AInteractionDirector::GetArchivementComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDirector", "GetArchivementComponent");

	Params::InteractionDirector_GetArchivementComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteraction.InteractionDirector.GetHolyLightComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UHolyLightComponent*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UHolyLightComponent* AInteractionDirector::GetHolyLightComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDirector", "GetHolyLightComponent");

	Params::InteractionDirector_GetHolyLightComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteraction.InteractionDirector.GetInteractionCharacterByName
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName&                      Name_0                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AInteractionCharacter*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AInteractionCharacter* AInteractionDirector::GetInteractionCharacterByName(const class FName& Name_0) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDirector", "GetInteractionCharacterByName");

	Params::InteractionDirector_GetInteractionCharacterByName Parms{};

	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteraction.InteractionDirector.IsInLittleGame
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AInteractionDirector::IsInLittleGame() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDirector", "IsInLittleGame");

	Params::InteractionDirector_IsInLittleGame Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteraction.InteractionDirector.IsMobilePlatform
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AInteractionDirector::IsMobilePlatform() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDirector", "IsMobilePlatform");

	Params::InteractionDirector_IsMobilePlatform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteraction.InteractionDirector.IsMouseInScreen
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AInteractionDirector::IsMouseInScreen() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDirector", "IsMouseInScreen");

	Params::InteractionDirector_IsMouseInScreen Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteraction.InteractionDirector.IsMousePressed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AInteractionDirector::IsMousePressed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDirector", "IsMousePressed");

	Params::InteractionDirector_IsMousePressed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteraction.InteractionLib.CalculateQuadraticBezierPoint
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   T                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   P0                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   P1                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   P2                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UInteractionLib::CalculateQuadraticBezierPoint(float T, const struct FVector& P0, const struct FVector& P1, const struct FVector& P2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InteractionLib", "CalculateQuadraticBezierPoint");

	Params::InteractionLib_CalculateQuadraticBezierPoint Parms{};

	Parms.T = T;
	Parms.P0 = std::move(P0);
	Parms.P1 = std::move(P1);
	Parms.P2 = std::move(P2);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteraction.InteractionLib.GetCharacterAnimation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    AnimName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    GirlName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    SkinAnimNameSuffix                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequence*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimSequence* UInteractionLib::GetCharacterAnimation(const class FString& AnimName, const class FString& GirlName, const class FString& SkinAnimNameSuffix)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InteractionLib", "GetCharacterAnimation");

	Params::InteractionLib_GetCharacterAnimation Parms{};

	Parms.AnimName = std::move(AnimName);
	Parms.GirlName = std::move(GirlName);
	Parms.SkinAnimNameSuffix = std::move(SkinAnimNameSuffix);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteraction.InteractionLib.GetSkeletonMeshTriangle
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           Mesh                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector2D&                 CanvasSize                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   WorldPosition                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Dir                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D*                       HitPosition                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   Hit                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LOD                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FCanvasUVTri>             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FCanvasUVTri> UInteractionLib::GetSkeletonMeshTriangle(class USkeletalMeshComponent* Mesh, const struct FVector2D& CanvasSize, const struct FVector& WorldPosition, const struct FVector& Dir, struct FVector2D* HitPosition, bool* Hit, int32 LOD)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InteractionLib", "GetSkeletonMeshTriangle");

	Params::InteractionLib_GetSkeletonMeshTriangle Parms{};

	Parms.Mesh = Mesh;
	Parms.CanvasSize = std::move(CanvasSize);
	Parms.WorldPosition = std::move(WorldPosition);
	Parms.Dir = std::move(Dir);
	Parms.LOD = LOD;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (HitPosition != nullptr)
		*HitPosition = std::move(Parms.HitPosition);

	if (Hit != nullptr)
		*Hit = Parms.Hit;

	return Parms.ReturnValue;
}


// Function CharacterInteraction.InteractionLib.GetSkeletonTriangleInfo
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           Mesh                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   WorldPosition                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Dir                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D*                       HitUV                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor*                    HitColor                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   Hit                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LOD                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionLib::GetSkeletonTriangleInfo(class USkeletalMeshComponent* Mesh, const struct FVector& WorldPosition, const struct FVector& Dir, struct FVector2D* HitUV, struct FLinearColor* HitColor, bool* Hit, int32 LOD)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InteractionLib", "GetSkeletonTriangleInfo");

	Params::InteractionLib_GetSkeletonTriangleInfo Parms{};

	Parms.Mesh = Mesh;
	Parms.WorldPosition = std::move(WorldPosition);
	Parms.Dir = std::move(Dir);
	Parms.LOD = LOD;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (HitUV != nullptr)
		*HitUV = std::move(Parms.HitUV);

	if (HitColor != nullptr)
		*HitColor = std::move(Parms.HitColor);

	if (Hit != nullptr)
		*Hit = Parms.Hit;
}


// Function CharacterInteraction.InteractionLib.NotifyEasterEggSequence
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class ULevelSequence*             EasterEgg                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionLib::NotifyEasterEggSequence(const class ULevelSequence* EasterEgg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InteractionLib", "NotifyEasterEggSequence");

	Params::InteractionLib_NotifyEasterEggSequence Parms{};

	Parms.EasterEgg = EasterEgg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionLib.NotifyLeaveFeatureScenario
// (Final, Native, Static, Public, BlueprintCallable)

void UInteractionLib::NotifyLeaveFeatureScenario()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InteractionLib", "NotifyLeaveFeatureScenario");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionLib.NotifyOperateState
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionLib::NotifyOperateState(int32 State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InteractionLib", "NotifyOperateState");

	Params::InteractionLib_NotifyOperateState Parms{};

	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionLib.NotifyTutorialPlayShowSequence
// (Final, Native, Static, Public, BlueprintCallable)

void UInteractionLib::NotifyTutorialPlayShowSequence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InteractionLib", "NotifyTutorialPlayShowSequence");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionLittleGame.EnterGame
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionLittleGame::EnterGame(int32 ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionLittleGame", "EnterGame");

	Params::InteractionLittleGame_EnterGame Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionLittleGame.LeaveGame
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UInteractionLittleGame::LeaveGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionLittleGame", "LeaveGame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionLittleGame.UpdateGame
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionLittleGame::UpdateGame(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionLittleGame", "UpdateGame");

	Params::InteractionLittleGame_UpdateGame Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionLittleGameComponent.Clear
// (Final, Native, Public, BlueprintCallable)

void UInteractionLittleGameComponent::Clear()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionLittleGameComponent", "Clear");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionLittleGameComponent.SetIsInLittleGame
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsInGame                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionLittleGameComponent::SetIsInLittleGame(bool bIsInGame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionLittleGameComponent", "SetIsInLittleGame");

	Params::InteractionLittleGameComponent_SetIsInLittleGame Parms{};

	Parms.bIsInGame = bIsInGame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionLittleGameComponent.StartLittleGame
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionLittleGameComponent::StartLittleGame(int32 ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionLittleGameComponent", "StartLittleGame");

	Params::InteractionLittleGameComponent_StartLittleGame Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionLittleGameComponent.StopLittleGame
// (Final, Native, Public, BlueprintCallable)

void UInteractionLittleGameComponent::StopLittleGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionLittleGameComponent", "StopLittleGame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionLittleGameComponent.GetIsInLittleGame
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionLittleGameComponent::GetIsInLittleGame() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionLittleGameComponent", "GetIsInLittleGame");

	Params::InteractionLittleGameComponent_GetIsInLittleGame Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteraction.PhyOperate.DoEndOperate
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AInteractionCharacter*            Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhyOperate::DoEndOperate(class AInteractionCharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhyOperate", "DoEndOperate");

	Params::PhyOperate_DoEndOperate Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.PhyOperate.DoStartOperate
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AInteractionCharacter*            Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhyOperate::DoStartOperate(class AInteractionCharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhyOperate", "DoStartOperate");

	Params::PhyOperate_DoStartOperate Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.PhyOperate.DoUpdateOperate
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AInteractionCharacter*            Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhyOperate::DoUpdateOperate(class AInteractionCharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhyOperate", "DoUpdateOperate");

	Params::PhyOperate_DoUpdateOperate Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.ExtraPhysicsBlendInterface.ExtraEndBlend
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IExtraPhysicsBlendInterface::ExtraEndBlend()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("ExtraPhysicsBlendInterface", "ExtraEndBlend");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.ExtraPhysicsBlendInterface.ExtraStartBlend
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IExtraPhysicsBlendInterface::ExtraStartBlend()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("ExtraPhysicsBlendInterface", "ExtraStartBlend");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.ExtraPhysicsBlendInterface.ExtraUpdatingBlend
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IExtraPhysicsBlendInterface::ExtraUpdatingBlend(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("ExtraPhysicsBlendInterface", "ExtraUpdatingBlend");

	Params::ExtraPhysicsBlendInterface_ExtraUpdatingBlend Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionPhysComponent.CreatePhysicsControl
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FInteractionPhysicsControlData&Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UInteractionPhysComponent::CreatePhysicsControl(const struct FInteractionPhysicsControlData& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionPhysComponent", "CreatePhysicsControl");

	Params::InteractionPhysComponent_CreatePhysicsControl Parms{};

	Parms.Data = std::move(Data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionPhysComponent.DestroyPhysicsControl
// (Final, Native, Public, BlueprintCallable)

void UInteractionPhysComponent::DestroyPhysicsControl()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionPhysComponent", "DestroyPhysicsControl");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionPhysComponent.DisableBreastPhysicsControl
// (Final, Native, Public, BlueprintCallable)

void UInteractionPhysComponent::DisableBreastPhysicsControl()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionPhysComponent", "DisableBreastPhysicsControl");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionPhysComponent.DisableHipPhysicsControl
// (Final, Native, Public, BlueprintCallable)

void UInteractionPhysComponent::DisableHipPhysicsControl()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionPhysComponent", "DisableHipPhysicsControl");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionPhysComponent.GetControlDataTemplate
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      Name_0                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bHasData                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPhysicsControlData*             OutData                                                (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UInteractionPhysComponent::GetControlDataTemplate(const class FName& Name_0, bool* bHasData, struct FPhysicsControlData* OutData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionPhysComponent", "GetControlDataTemplate");

	Params::InteractionPhysComponent_GetControlDataTemplate Parms{};

	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bHasData != nullptr)
		*bHasData = Parms.bHasData;

	if (OutData != nullptr)
		*OutData = std::move(Parms.OutData);
}


// Function CharacterInteraction.InteractionPhysComponent.InitPhysicsControl
// (Final, Native, Public, BlueprintCallable)

void UInteractionPhysComponent::InitPhysicsControl()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionPhysComponent", "InitPhysicsControl");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionPhysComponent.InitTineLine
// (Final, Native, Public)

void UInteractionPhysComponent::InitTineLine()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionPhysComponent", "InitTineLine");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionPhysComponent.InvokeControlProfile
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ProfileName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionPhysComponent::InvokeControlProfile(class FName ProfileName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionPhysComponent", "InvokeControlProfile");

	Params::InteractionPhysComponent_InvokeControlProfile Parms{};

	Parms.ProfileName = ProfileName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteraction.InteractionPhysComponent.IsEnableBreastPhy
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionPhysComponent::IsEnableBreastPhy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionPhysComponent", "IsEnableBreastPhy");

	Params::InteractionPhysComponent_IsEnableBreastPhy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteraction.InteractionPhysComponent.IsEnableHipPhy
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionPhysComponent::IsEnableHipPhy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionPhysComponent", "IsEnableHipPhy");

	Params::InteractionPhysComponent_IsEnableHipPhy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteraction.InteractionPhysComponent.OnTimelineFinished
// (Final, Native, Public)

void UInteractionPhysComponent::OnTimelineFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionPhysComponent", "OnTimelineFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionPhysComponent.PlayTimeLineFromStart
// (Final, Native, Public)
// Parameters:
// float                                   TimelineLength                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionPhysComponent::PlayTimeLineFromStart(float TimelineLength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionPhysComponent", "PlayTimeLineFromStart");

	Params::InteractionPhysComponent_PlayTimeLineFromStart Parms{};

	Parms.TimelineLength = TimelineLength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionPhysComponent.StopPhysicsBlendTimeLine
// (Final, Native, Public, BlueprintCallable)

void UInteractionPhysComponent::StopPhysicsBlendTimeLine()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionPhysComponent", "StopPhysicsBlendTimeLine");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionPhysComponent.TimelineReturn_SetParentMultipliers
// (Final, Native, Public)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionPhysComponent::TimelineReturn_SetParentMultipliers(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionPhysComponent", "TimelineReturn_SetParentMultipliers");

	Params::InteractionPhysComponent_TimelineReturn_SetParentMultipliers Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionPhysComponent.TimelineReturn_SetPhysicsBlendWeight
// (Final, Native, Public)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionPhysComponent::TimelineReturn_SetPhysicsBlendWeight(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionPhysComponent", "TimelineReturn_SetPhysicsBlendWeight");

	Params::InteractionPhysComponent_TimelineReturn_SetPhysicsBlendWeight Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionPhysComponent.TimelineReturn_SetWorldMultipliers
// (Final, Native, Public)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionPhysComponent::TimelineReturn_SetWorldMultipliers(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionPhysComponent", "TimelineReturn_SetWorldMultipliers");

	Params::InteractionPhysComponent_TimelineReturn_SetWorldMultipliers Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionPhysComponent.UpdateBodyModifiersMovementType
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsEnable                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionPhysComponent::UpdateBodyModifiersMovementType(float Duration, bool bIsEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionPhysComponent", "UpdateBodyModifiersMovementType");

	Params::InteractionPhysComponent_UpdateBodyModifiersMovementType Parms{};

	Parms.Duration = Duration;
	Parms.bIsEnable = bIsEnable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CharacterInteraction.InteractionPhysComponent.GetInitParam
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FInteractionPhysicsControlData   ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FInteractionPhysicsControlData UInteractionPhysComponent::GetInitParam() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionPhysComponent", "GetInitParam");

	Params::InteractionPhysComponent_GetInitParam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteraction.InteractionPhysComponent.GetInteractionPhysConfig
// (Final, Native, Public, Const)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FInteractionPhysicsControlDataReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FInteractionPhysicsControlData UInteractionPhysComponent::GetInteractionPhysConfig(class FName ID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionPhysComponent", "GetInteractionPhysConfig");

	Params::InteractionPhysComponent_GetInteractionPhysConfig Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteraction.InteractionPhysComponent.GetPhysicsControlProfiles
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPhysicsControlDataProfiles*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPhysicsControlDataProfiles* UInteractionPhysComponent::GetPhysicsControlProfiles() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionPhysComponent", "GetPhysicsControlProfiles");

	Params::InteractionPhysComponent_GetPhysicsControlProfiles Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteraction.InteractionPhysComponent.GetTargetPcc
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPhysicsControlComponent*         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPhysicsControlComponent* UInteractionPhysComponent::GetTargetPcc() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionPhysComponent", "GetTargetPcc");

	Params::InteractionPhysComponent_GetTargetPcc Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteraction.InteractionAction.DoAction
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UInteractionEventContext*         Context                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionAction::DoAction(class UInteractionEventContext* Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionAction", "DoAction");

	Params::InteractionAction_DoAction Parms{};

	Parms.Context = Context;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionTrigger.PhysicsBlend
// (Native, Public, BlueprintCallable, Const)
// Parameters:
// class UInteractionEventContext*         Context                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionTrigger::PhysicsBlend(class UInteractionEventContext* Context) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionTrigger", "PhysicsBlend");

	Params::InteractionTrigger_PhysicsBlend Parms{};

	Parms.Context = Context;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.InteractionTrigger.ShouldTrigger
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class UInteractionEventContext*         Context                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionTrigger::ShouldTrigger(class UInteractionEventContext* Context) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionTrigger", "ShouldTrigger");

	Params::InteractionTrigger_ShouldTrigger Parms{};

	Parms.Context = Context;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteraction.InteractionEvent.IsTriggered
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionEvent::IsTriggered() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionEvent", "IsTriggered");

	Params::InteractionEvent_IsTriggered Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteraction.CustomShowElement.EndShowElement
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AInteractionCharacter*            Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomShowElement::EndShowElement(class AInteractionCharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomShowElement", "EndShowElement");

	Params::CustomShowElement_EndShowElement Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.CustomShowElement.PlayShowElement
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AInteractionCharacter*            Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomShowElement::PlayShowElement(class AInteractionCharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomShowElement", "PlayShowElement");

	Params::CustomShowElement_PlayShowElement Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.CustomShowElement.UpdateShowElement
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AInteractionCharacter*            Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomShowElement::UpdateShowElement(class AInteractionCharacter* Character, float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomShowElement", "UpdateShowElement");

	Params::CustomShowElement_UpdateShowElement Parms{};

	Parms.Character = Character;
	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.CustomShowElement.IsShowEnd
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class AInteractionCharacter*            Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomShowElement::IsShowEnd(class AInteractionCharacter* Character) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomShowElement", "IsShowEnd");

	Params::CustomShowElement_IsShowEnd Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CharacterInteraction.ScenarioInitialActionBase.DoAction
// (Native, Event, Public, BlueprintEvent)

void UScenarioInitialActionBase::DoAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioInitialActionBase", "DoAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.ScenarioExitActionBase.DoAction
// (Native, Event, Public, BlueprintEvent)

void UScenarioExitActionBase::DoAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScenarioExitActionBase", "DoAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CharacterInteraction.SimpleQTE.DelayNotifyStartLittleGame
// (Final, Native, Private)
// Parameters:
// int32                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USimpleQTE::DelayNotifyStartLittleGame(int32 ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SimpleQTE", "DelayNotifyStartLittleGame");

	Params::SimpleQTE_DelayNotifyStartLittleGame Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}

