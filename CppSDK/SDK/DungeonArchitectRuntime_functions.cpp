#pragma once

/*
* SDK generated by Rei-SdkDumper
* Based on Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DungeonArchitectRuntime

#include "Basic.hpp"

#include "DungeonArchitectRuntime_classes.hpp"
#include "DungeonArchitectRuntime_parameters.hpp"


namespace SDK
{

// Function DungeonArchitectRuntime.Dungeon.GetDungeonActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADungeon*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADungeon* ADungeon::GetDungeonActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Dungeon", "GetDungeonActor");

	Params::Dungeon_GetDungeonActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonArchitectRuntime.Dungeon.GetDungeonLevelNumber
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    SceneObject                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ADungeon::GetDungeonLevelNumber(const class UObject* SceneObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Dungeon", "GetDungeonLevelNumber");

	Params::Dungeon_GetDungeonLevelNumber Parms{};

	Parms.SceneObject = SceneObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonArchitectRuntime.Dungeon.BuildDungeon
// (Final, Native, Public, BlueprintCallable)

void ADungeon::BuildDungeon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Dungeon", "BuildDungeon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonArchitectRuntime.Dungeon.DestroyDungeon
// (Final, Native, Public, BlueprintCallable)

void ADungeon::DestroyDungeon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Dungeon", "DestroyDungeon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonArchitectRuntime.Dungeon.GetQuery
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDungeonQuery*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDungeonQuery* ADungeon::GetQuery()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Dungeon", "GetQuery");

	Params::Dungeon_GetQuery Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonArchitectRuntime.Dungeon.SetBuilderClass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UDungeonBuilder>      InBuilderClass                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDungeonBuilder*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDungeonBuilder* ADungeon::SetBuilderClass(TSubclassOf<class UDungeonBuilder> InBuilderClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Dungeon", "SetBuilderClass");

	Params::Dungeon_SetBuilderClass Parms{};

	Parms.InBuilderClass = InBuilderClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonArchitectRuntime.DungeonBPFunctionLibrary.ActorBelongsToDungeon
// (Final, Native, Static, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// class ADungeon*                         Dungeon                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ActorToCheck                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDungeonBPFunctionLibrary::ActorBelongsToDungeon(class ADungeon* Dungeon, class AActor* ActorToCheck)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DungeonBPFunctionLibrary", "ActorBelongsToDungeon");

	Params::DungeonBPFunctionLibrary_ActorBelongsToDungeon Parms{};

	Parms.Dungeon = Dungeon;
	Parms.ActorToCheck = ActorToCheck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonArchitectRuntime.DungeonBPFunctionLibrary.DungeonObjectHasAuthority
// (Final, Native, Static, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDungeonBPFunctionLibrary::DungeonObjectHasAuthority(class UObject* Object)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DungeonBPFunctionLibrary", "DungeonObjectHasAuthority");

	Params::DungeonBPFunctionLibrary_DungeonObjectHasAuthority Parms{};

	Parms.Object = Object;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonArchitectRuntime.DungeonBPFunctionLibrary.SpawnDungeonOwnedActor
// (Final, Native, Static, Private, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class ADungeon*                         Dungeon                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               ActorClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                Transform                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UDungeonBPFunctionLibrary::SpawnDungeonOwnedActor(class ADungeon* Dungeon, TSubclassOf<class AActor> ActorClass, const struct FTransform& Transform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DungeonBPFunctionLibrary", "SpawnDungeonOwnedActor");

	Params::DungeonBPFunctionLibrary_SpawnDungeonOwnedActor Parms{};

	Parms.Dungeon = Dungeon;
	Parms.ActorClass = ActorClass;
	Parms.Transform = std::move(Transform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonArchitectRuntime.DungeonBPFunctionLibrary.StreamDungeonModuleLevel
// (Final, Native, Static, Private, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UWorld>            Level                                                  (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InstanceId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  Rotation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool*                                   bOutSuccess                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULevelStreamingDynamic*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULevelStreamingDynamic* UDungeonBPFunctionLibrary::StreamDungeonModuleLevel(class UObject* WorldContextObject, TSoftObjectPtr<class UWorld> Level, int32 InstanceId, const struct FVector& Location, const struct FRotator& Rotation, bool* bOutSuccess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DungeonBPFunctionLibrary", "StreamDungeonModuleLevel");

	Params::DungeonBPFunctionLibrary_StreamDungeonModuleLevel Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Level = Level;
	Parms.InstanceId = InstanceId;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOutSuccess != nullptr)
		*bOutSuccess = Parms.bOutSuccess;

	return Parms.ReturnValue;
}


// Function DungeonArchitectRuntime.DungeonBuilder.EmitDungeonMarkers
// (Native, Event, Public, BlueprintEvent)

void UDungeonBuilder::EmitDungeonMarkers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonBuilder", "EmitDungeonMarkers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonArchitectRuntime.DungeonBuilder.EmitMarker
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class FString&                    SocketType                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                Transform                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UDungeonBuilder::EmitMarker(const class FString& SocketType, const struct FTransform& Transform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonBuilder", "EmitMarker");

	Params::DungeonBuilder_EmitMarker Parms{};

	Parms.SocketType = std::move(SocketType);
	Parms.Transform = std::move(Transform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonArchitectRuntime.DungeonBuilder.GetMarkers
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FPropSocket>              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FPropSocket> UDungeonBuilder::GetMarkers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonBuilder", "GetMarkers");

	Params::DungeonBuilder_GetMarkers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonArchitectRuntime.DungeonEventListener.OnDungeonDestroyed
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class ADungeon*                         Dungeon                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDungeonEventListener::OnDungeonDestroyed(class ADungeon* Dungeon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonEventListener", "OnDungeonDestroyed");

	Params::DungeonEventListener_OnDungeonDestroyed Parms{};

	Parms.Dungeon = Dungeon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonArchitectRuntime.DungeonEventListener.OnDungeonLayoutBuilt
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class ADungeon*                         Dungeon                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDungeonEventListener::OnDungeonLayoutBuilt(class ADungeon* Dungeon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonEventListener", "OnDungeonLayoutBuilt");

	Params::DungeonEventListener_OnDungeonLayoutBuilt Parms{};

	Parms.Dungeon = Dungeon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonArchitectRuntime.DungeonEventListener.OnMarkersEmitted
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class ADungeon*                         Dungeon                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FDungeonMarkerInfo>&      MarkerList                                             (Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TArray<struct FDungeonMarkerInfo>*      MarkerListRef                                          (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UDungeonEventListener::OnMarkersEmitted(class ADungeon* Dungeon, TArray<struct FDungeonMarkerInfo>& MarkerList, TArray<struct FDungeonMarkerInfo>* MarkerListRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonEventListener", "OnMarkersEmitted");

	Params::DungeonEventListener_OnMarkersEmitted Parms{};

	Parms.Dungeon = Dungeon;
	Parms.MarkerList = std::move(MarkerList);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	MarkerList = std::move(Parms.MarkerList);

	if (MarkerListRef != nullptr)
		*MarkerListRef = std::move(Parms.MarkerListRef);
}


// Function DungeonArchitectRuntime.DungeonEventListener.OnPostDungeonBuild
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class ADungeon*                         Dungeon                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDungeonEventListener::OnPostDungeonBuild(class ADungeon* Dungeon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonEventListener", "OnPostDungeonBuild");

	Params::DungeonEventListener_OnPostDungeonBuild Parms{};

	Parms.Dungeon = Dungeon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonArchitectRuntime.DungeonEventListener.OnPreDungeonBuild
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class ADungeon*                         Dungeon                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDungeonEventListener::OnPreDungeonBuild(class ADungeon* Dungeon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonEventListener", "OnPreDungeonBuild");

	Params::DungeonEventListener_OnPreDungeonBuild Parms{};

	Parms.Dungeon = Dungeon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonArchitectRuntime.DungeonEventListener.OnPreDungeonDestroy
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class ADungeon*                         Dungeon                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDungeonEventListener::OnPreDungeonDestroy(class ADungeon* Dungeon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonEventListener", "OnPreDungeonDestroy");

	Params::DungeonEventListener_OnPreDungeonDestroy Parms{};

	Parms.Dungeon = Dungeon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonArchitectRuntime.DungeonStreamingLevel.HandleChunkHidden
// (Native, Protected)

void UDungeonStreamingLevel::HandleChunkHidden()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonStreamingLevel", "HandleChunkHidden");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonArchitectRuntime.DungeonStreamingLevel.HandleChunkLoaded
// (Native, Protected)

void UDungeonStreamingLevel::HandleChunkLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonStreamingLevel", "HandleChunkLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonArchitectRuntime.DungeonStreamingLevel.HandleChunkUnloaded
// (Native, Protected)

void UDungeonStreamingLevel::HandleChunkUnloaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonStreamingLevel", "HandleChunkUnloaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonArchitectRuntime.DungeonStreamingLevel.HandleChunkVisible
// (Native, Protected)

void UDungeonStreamingLevel::HandleChunkVisible()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonStreamingLevel", "HandleChunkVisible");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonArchitectRuntime.DungeonStreamingChunk.GetAllActorsOfClass
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UClass*                           InClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>*                  OutActors                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UDungeonStreamingChunk::GetAllActorsOfClass(class UClass* InClass, TArray<class AActor*>* OutActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonStreamingChunk", "GetAllActorsOfClass");

	Params::DungeonStreamingChunk_GetAllActorsOfClass Parms{};

	Parms.InClass = InClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutActors != nullptr)
		*OutActors = std::move(Parms.OutActors);
}


// Function DungeonArchitectRuntime.DungeonStreamingChunk.HandleChunkHidden
// (Native, Public)

void UDungeonStreamingChunk::HandleChunkHidden()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonStreamingChunk", "HandleChunkHidden");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonArchitectRuntime.DungeonStreamingChunk.HandleChunkLoaded
// (Native, Public)

void UDungeonStreamingChunk::HandleChunkLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonStreamingChunk", "HandleChunkLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonArchitectRuntime.DungeonStreamingChunk.HandleChunkUnloaded
// (Native, Public)

void UDungeonStreamingChunk::HandleChunkUnloaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonStreamingChunk", "HandleChunkUnloaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonArchitectRuntime.DungeonStreamingChunk.HandleChunkVisible
// (Native, Public)

void UDungeonStreamingChunk::HandleChunkVisible()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonStreamingChunk", "HandleChunkVisible");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonArchitectRuntime.DungeonLevelStreamingModel.OnRep_ChunkParamsToClient
// (Final, Native, Private)

void UDungeonLevelStreamingModel::OnRep_ChunkParamsToClient()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonLevelStreamingModel", "OnRep_ChunkParamsToClient");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonArchitectRuntime.DungeonMarkerEmitter.EmitMarkers
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UDungeonBuilder*                  Builder                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDungeonModel*                    Model                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDungeonConfig*                   Config                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDungeonQuery*                    Query                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDungeonMarkerEmitter::EmitMarkers(class UDungeonBuilder* Builder, class UDungeonModel* Model, class UDungeonConfig* Config, class UDungeonQuery* Query)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonMarkerEmitter", "EmitMarkers");

	Params::DungeonMarkerEmitter_EmitMarkers Parms{};

	Parms.Builder = Builder;
	Parms.Model = Model;
	Parms.Config = Config;
	Parms.Query = Query;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonArchitectRuntime.DungeonMiniMap.BuildLayout
// (Native, Public, BlueprintCallable)
// Parameters:
// class UDungeonModel*                    DungeonModel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDungeonConfig*                   DungeonConfig                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADungeonMiniMap::BuildLayout(class UDungeonModel* DungeonModel, class UDungeonConfig* DungeonConfig)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonMiniMap", "BuildLayout");

	Params::DungeonMiniMap_BuildLayout Parms{};

	Parms.DungeonModel = DungeonModel;
	Parms.DungeonConfig = DungeonConfig;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonArchitectRuntime.DungeonMiniMap.CreateMaterialInstance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInterface*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInterface* ADungeonMiniMap::CreateMaterialInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonMiniMap", "CreateMaterialInstance");

	Params::DungeonMiniMap_CreateMaterialInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonArchitectRuntime.DungeonMiniMap.CreateMaterialInstanceFromTemplate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInterface*               InMaterialTemplate                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInterface* ADungeonMiniMap::CreateMaterialInstanceFromTemplate(class UMaterialInterface* InMaterialTemplate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonMiniMap", "CreateMaterialInstanceFromTemplate");

	Params::DungeonMiniMap_CreateMaterialInstanceFromTemplate Parms{};

	Parms.InMaterialTemplate = InMaterialTemplate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonArchitectRuntime.DungeonMiniMap.UpdateMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInterface*               InMaterial                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADungeonMiniMap::UpdateMaterial(class UMaterialInterface* InMaterial)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonMiniMap", "UpdateMaterial");

	Params::DungeonMiniMap_UpdateMaterial Parms{};

	Parms.InMaterial = InMaterial;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonArchitectRuntime.DungeonModelHelper.ExpandBounds
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FRectangle&                Bounds                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRectangle*                      Result                                                 (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UDungeonModelHelper::ExpandBounds(const struct FRectangle& Bounds, int32 Size, struct FRectangle* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DungeonModelHelper", "ExpandBounds");

	Params::DungeonModelHelper_ExpandBounds Parms{};

	Parms.Bounds = std::move(Bounds);
	Parms.Size = Size;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = std::move(Parms.Result);
}


// Function DungeonArchitectRuntime.DungeonModelHelper.GetCenterExtent
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FRectangle&                Rectangle                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector*                         Center                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         Extent                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDungeonModelHelper::GetCenterExtent(const struct FRectangle& Rectangle, struct FVector* Center, struct FVector* Extent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DungeonModelHelper", "GetCenterExtent");

	Params::DungeonModelHelper_GetCenterExtent Parms{};

	Parms.Rectangle = std::move(Rectangle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Center != nullptr)
		*Center = std::move(Parms.Center);

	if (Extent != nullptr)
		*Extent = std::move(Parms.Extent);
}


// Function DungeonArchitectRuntime.DungeonModelHelper.GetRectAreaPoints
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FRectangle&                Rectangle                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<struct FIntVector>*              BorderPoints                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UDungeonModelHelper::GetRectAreaPoints(const struct FRectangle& Rectangle, TArray<struct FIntVector>* BorderPoints)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DungeonModelHelper", "GetRectAreaPoints");

	Params::DungeonModelHelper_GetRectAreaPoints Parms{};

	Parms.Rectangle = std::move(Rectangle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (BorderPoints != nullptr)
		*BorderPoints = std::move(Parms.BorderPoints);
}


// Function DungeonArchitectRuntime.DungeonModelHelper.GetRectBorderPoints
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FRectangle&                Rectangle                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<struct FIntVector>*              BorderPoints                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UDungeonModelHelper::GetRectBorderPoints(const struct FRectangle& Rectangle, TArray<struct FIntVector>* BorderPoints)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DungeonModelHelper", "GetRectBorderPoints");

	Params::DungeonModelHelper_GetRectBorderPoints Parms{};

	Parms.Rectangle = std::move(Rectangle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (BorderPoints != nullptr)
		*BorderPoints = std::move(Parms.BorderPoints);
}


// Function DungeonArchitectRuntime.DungeonModelHelper.MakeIntVector
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   In                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntVector                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntVector UDungeonModelHelper::MakeIntVector(const struct FVector& In)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DungeonModelHelper", "MakeIntVector");

	Params::DungeonModelHelper_MakeIntVector Parms{};

	Parms.In = std::move(In);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonArchitectRuntime.DungeonModelHelper.MakeVector
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FIntVector&                In                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UDungeonModelHelper::MakeVector(const struct FIntVector& In, float Scale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DungeonModelHelper", "MakeVector");

	Params::DungeonModelHelper_MakeVector Parms{};

	Parms.In = std::move(In);
	Parms.Scale = Scale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonArchitectRuntime.DungeonNavLinkProxy.SetupSmartLinkData
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Start                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   End                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENavLinkDirection                       Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADungeonNavLinkProxy::SetupSmartLinkData(const struct FVector& Start, const struct FVector& End, ENavLinkDirection Direction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonNavLinkProxy", "SetupSmartLinkData");

	Params::DungeonNavLinkProxy_SetupSmartLinkData Parms{};

	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.Direction = Direction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonArchitectRuntime.DungeonQueryUserState.ClearAllState
// (Final, Native, Public, BlueprintCallable)

void UDungeonQueryUserState::ClearAllState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonQueryUserState", "ClearAllState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonArchitectRuntime.DungeonQueryUserState.GetBool
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      Name_0                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDungeonQueryUserState::GetBool(const class FName& Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonQueryUserState", "GetBool");

	Params::DungeonQueryUserState_GetBool Parms{};

	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonArchitectRuntime.DungeonQueryUserState.GetFloat
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      Name_0                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDungeonQueryUserState::GetFloat(const class FName& Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonQueryUserState", "GetFloat");

	Params::DungeonQueryUserState_GetFloat Parms{};

	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonArchitectRuntime.DungeonQueryUserState.GetInt
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      Name_0                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDungeonQueryUserState::GetInt(const class FName& Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonQueryUserState", "GetInt");

	Params::DungeonQueryUserState_GetInt Parms{};

	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonArchitectRuntime.DungeonQueryUserState.GetString
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      Name_0                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UDungeonQueryUserState::GetString(const class FName& Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonQueryUserState", "GetString");

	Params::DungeonQueryUserState_GetString Parms{};

	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonArchitectRuntime.DungeonQueryUserState.GetVector
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName&                      Name_0                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UDungeonQueryUserState::GetVector(const class FName& Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonQueryUserState", "GetVector");

	Params::DungeonQueryUserState_GetVector Parms{};

	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonArchitectRuntime.DungeonQueryUserState.SetBool
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      Name_0                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDungeonQueryUserState::SetBool(const class FName& Name_0, bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonQueryUserState", "SetBool");

	Params::DungeonQueryUserState_SetBool Parms{};

	Parms.Name_0 = Name_0;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonArchitectRuntime.DungeonQueryUserState.SetFloat
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      Name_0                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDungeonQueryUserState::SetFloat(const class FName& Name_0, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonQueryUserState", "SetFloat");

	Params::DungeonQueryUserState_SetFloat Parms{};

	Parms.Name_0 = Name_0;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonArchitectRuntime.DungeonQueryUserState.SetInt
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      Name_0                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDungeonQueryUserState::SetInt(const class FName& Name_0, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonQueryUserState", "SetInt");

	Params::DungeonQueryUserState_SetInt Parms{};

	Parms.Name_0 = Name_0;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonArchitectRuntime.DungeonQueryUserState.SetString
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      Name_0                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Value                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDungeonQueryUserState::SetString(const class FName& Name_0, const class FString& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonQueryUserState", "SetString");

	Params::DungeonQueryUserState_SetString Parms{};

	Parms.Name_0 = Name_0;
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonArchitectRuntime.DungeonQueryUserState.SetVector
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class FName&                      Name_0                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Value                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDungeonQueryUserState::SetVector(const class FName& Name_0, const struct FVector& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonQueryUserState", "SetVector");

	Params::DungeonQueryUserState_SetVector Parms{};

	Parms.Name_0 = Name_0;
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonArchitectRuntime.SnapMapDungeonTransformLogic.GetNodeOffset
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// class USnapMapDungeonModel*             Model                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform*                      Offset                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void USnapMapDungeonTransformLogic::GetNodeOffset(class USnapMapDungeonModel* Model, struct FTransform* Offset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SnapMapDungeonTransformLogic", "GetNodeOffset");

	Params::SnapMapDungeonTransformLogic_GetNodeOffset Parms{};

	Parms.Model = Model;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Offset != nullptr)
		*Offset = std::move(Parms.Offset);
}


// Function DungeonArchitectRuntime.DungeonSpawnLogic.OnItemSpawn
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADungeon*                         Dungeon                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDungeonSpawnLogic::OnItemSpawn(class AActor* Actor, class ADungeon* Dungeon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonSpawnLogic", "OnItemSpawn");

	Params::DungeonSpawnLogic_OnItemSpawn Parms{};

	Parms.Actor = Actor;
	Parms.Dungeon = Dungeon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonArchitectRuntime.SnapMapDungeonBuilder.BuildPreviewSnapLayout
// (Final, Native, Public, BlueprintCallable)

void USnapMapDungeonBuilder::BuildPreviewSnapLayout()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SnapMapDungeonBuilder", "BuildPreviewSnapLayout");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonArchitectRuntime.FloorPlanSelectorLogic.SelectNode
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// class UFloorPlanModel*                  Model                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFloorPlanConfig*                 Config                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRandomStream&             RandomStream                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   GridX                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   GridY                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   GridZ                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFloorPlanSelectorLogic::SelectNode(class UFloorPlanModel* Model, class UFloorPlanConfig* Config, const struct FRandomStream& RandomStream, int32 GridX, int32 GridY, int32 GridZ)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FloorPlanSelectorLogic", "SelectNode");

	Params::FloorPlanSelectorLogic_SelectNode Parms{};

	Parms.Model = Model;
	Parms.Config = Config;
	Parms.RandomStream = std::move(RandomStream);
	Parms.GridX = GridX;
	Parms.GridY = GridY;
	Parms.GridZ = GridZ;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonArchitectRuntime.FloorPlanTransformLogic.GetNodeOffset
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// class UFloorPlanModel*                  Model                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFloorPlanConfig*                 Config                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRandomStream&             RandomStream                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   GridX                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   GridY                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform*                      Offset                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UFloorPlanTransformLogic::GetNodeOffset(class UFloorPlanModel* Model, class UFloorPlanConfig* Config, const struct FRandomStream& RandomStream, int32 GridX, int32 GridY, struct FTransform* Offset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FloorPlanTransformLogic", "GetNodeOffset");

	Params::FloorPlanTransformLogic_GetNodeOffset Parms{};

	Parms.Model = Model;
	Parms.Config = Config;
	Parms.RandomStream = std::move(RandomStream);
	Parms.GridX = GridX;
	Parms.GridY = GridY;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Offset != nullptr)
		*Offset = std::move(Parms.Offset);
}


// Function DungeonArchitectRuntime.FlowAbstractNode.ContainsItem
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// EFlowGraphItemType                      ItemType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  Count                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlowAbstractNode::ContainsItem(EFlowGraphItemType ItemType, int32* Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowAbstractNode", "ContainsItem");

	Params::FlowAbstractNode_ContainsItem Parms{};

	Parms.ItemType = ItemType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Count != nullptr)
		*Count = Parms.Count;

	return Parms.ReturnValue;
}


// Function DungeonArchitectRuntime.SnapMapDungeonSelectorLogic.SelectNode
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class USnapMapDungeonModel*             Model                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USnapMapDungeonSelectorLogic::SelectNode(class USnapMapDungeonModel* Model)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SnapMapDungeonSelectorLogic", "SelectNode");

	Params::SnapMapDungeonSelectorLogic_SelectNode Parms{};

	Parms.Model = Model;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonArchitectRuntime.Grid3DLayoutNodeCreationConstraint.CanCreateLayoutNode
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// const struct FIntVector&                NodeCoord                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FIntVector&                GridSize                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TotalPathLength                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CurrentPathPosition                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGrid3DLayoutNodeCreationConstraint::CanCreateLayoutNode(const struct FIntVector& NodeCoord, const struct FIntVector& GridSize, int32 TotalPathLength, int32 CurrentPathPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Grid3DLayoutNodeCreationConstraint", "CanCreateLayoutNode");

	Params::Grid3DLayoutNodeCreationConstraint_CanCreateLayoutNode Parms{};

	Parms.NodeCoord = std::move(NodeCoord);
	Parms.GridSize = std::move(GridSize);
	Parms.TotalPathLength = TotalPathLength;
	Parms.CurrentPathPosition = CurrentPathPosition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonArchitectRuntime.GridDungeonBuilder.ContainsCell
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGridDungeonBuilder::ContainsCell(int32 X, int32 Y)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridDungeonBuilder", "ContainsCell");

	Params::GridDungeonBuilder_ContainsCell Parms{};

	Parms.X = X;
	Parms.Y = Y;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonArchitectRuntime.GridDungeonBuilder.GetCellsOfType
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// EFCellType                              CellType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FCell>*                   Cells                                                  (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UGridDungeonBuilder::GetCellsOfType(EFCellType CellType, TArray<struct FCell>* Cells)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridDungeonBuilder", "GetCellsOfType");

	Params::GridDungeonBuilder_GetCellsOfType Parms{};

	Parms.CellType = CellType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Cells != nullptr)
		*Cells = std::move(Parms.Cells);
}


// Function DungeonArchitectRuntime.GridDungeonBuilder.GetCorridors
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FCell>*                   CorridorCells                                          (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UGridDungeonBuilder::GetCorridors(TArray<struct FCell>* CorridorCells)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridDungeonBuilder", "GetCorridors");

	Params::GridDungeonBuilder_GetCorridors Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (CorridorCells != nullptr)
		*CorridorCells = std::move(Parms.CorridorCells);
}


// Function DungeonArchitectRuntime.GridDungeonBuilder.GetRandomStream
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRandomStream*                   OutRandomStream                                        (Parm, OutParm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void UGridDungeonBuilder::GetRandomStream(struct FRandomStream* OutRandomStream)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridDungeonBuilder", "GetRandomStream");

	Params::GridDungeonBuilder_GetRandomStream Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRandomStream != nullptr)
		*OutRandomStream = std::move(Parms.OutRandomStream);
}


// Function DungeonArchitectRuntime.GridDungeonBuilder.GetRooms
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FCell>*                   RoomCells                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UGridDungeonBuilder::GetRooms(TArray<struct FCell>* RoomCells)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridDungeonBuilder", "GetRooms");

	Params::GridDungeonBuilder_GetRooms Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (RoomCells != nullptr)
		*RoomCells = std::move(Parms.RoomCells);
}


// Function DungeonArchitectRuntime.GridCustomDungeonBuilder.ConnectRooms
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Room1                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Room2                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGridCustomDungeonBuilder::ConnectRooms(int32 Room1, int32 Room2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridCustomDungeonBuilder", "ConnectRooms");

	Params::GridCustomDungeonBuilder_ConnectRooms Parms{};

	Parms.Room1 = Room1;
	Parms.Room2 = Room2;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonArchitectRuntime.GridCustomDungeonBuilder.GenerateCustomLayout
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UGridDungeonConfig*               GridConfig                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGridCustomDungeonBuilder::GenerateCustomLayout(class UGridDungeonConfig* GridConfig)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridCustomDungeonBuilder", "GenerateCustomLayout");

	Params::GridCustomDungeonBuilder_GenerateCustomLayout Parms{};

	Parms.GridConfig = GridConfig;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonArchitectRuntime.GridCustomDungeonBuilder.GetRandomOffset
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  OutX                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  OutY                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGridCustomDungeonBuilder::GetRandomOffset(int32 X, int32 Y, float Radius, int32* OutX, int32* OutY)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridCustomDungeonBuilder", "GetRandomOffset");

	Params::GridCustomDungeonBuilder_GetRandomOffset Parms{};

	Parms.X = X;
	Parms.Y = Y;
	Parms.Radius = Radius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutX != nullptr)
		*OutX = Parms.OutX;

	if (OutY != nullptr)
		*OutY = Parms.OutY;
}


// Function DungeonArchitectRuntime.GridCustomDungeonBuilder.RegisterRoom
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Z                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Width                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Height                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  RoomId                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGridCustomDungeonBuilder::RegisterRoom(int32 X, int32 Y, int32 Z, int32 Width, int32 Height, int32* RoomId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridCustomDungeonBuilder", "RegisterRoom");

	Params::GridCustomDungeonBuilder_RegisterRoom Parms{};

	Parms.X = X;
	Parms.Y = Y;
	Parms.Z = Z;
	Parms.Width = Width;
	Parms.Height = Height;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (RoomId != nullptr)
		*RoomId = Parms.RoomId;
}


// Function DungeonArchitectRuntime.GridCustomDungeonBuilder.RegisterRoomAt
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Z                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  RoomId                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGridCustomDungeonBuilder::RegisterRoomAt(int32 X, int32 Y, int32 Z, int32* RoomId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridCustomDungeonBuilder", "RegisterRoomAt");

	Params::GridCustomDungeonBuilder_RegisterRoomAt Parms{};

	Parms.X = X;
	Parms.Y = Y;
	Parms.Z = Z;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (RoomId != nullptr)
		*RoomId = Parms.RoomId;
}


// Function DungeonArchitectRuntime.GridDungeonModel.GetGridCellLookup
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGridCellInfo                    ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FGridCellInfo UGridDungeonModel::GetGridCellLookup(int32 X, int32 Y) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridDungeonModel", "GetGridCellLookup");

	Params::GridDungeonModel_GetGridCellLookup Parms{};

	Parms.X = X;
	Parms.Y = Y;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonArchitectRuntime.GridDungeonModelHelper.AddPaintCell
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGridToolPaintStrokeData&  CellData                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class ADungeon*                         Dungeon                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutomaticRebuild                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGridDungeonModelHelper::AddPaintCell(const struct FGridToolPaintStrokeData& CellData, class ADungeon* Dungeon, bool bAutomaticRebuild)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GridDungeonModelHelper", "AddPaintCell");

	Params::GridDungeonModelHelper_AddPaintCell Parms{};

	Parms.CellData = std::move(CellData);
	Parms.Dungeon = Dungeon;
	Parms.bAutomaticRebuild = bAutomaticRebuild;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonArchitectRuntime.GridDungeonModelHelper.GetBoundingBox
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<struct FCell>&             Cells                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FRectangle*                      Bounds                                                 (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UGridDungeonModelHelper::GetBoundingBox(const TArray<struct FCell>& Cells, struct FRectangle* Bounds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GridDungeonModelHelper", "GetBoundingBox");

	Params::GridDungeonModelHelper_GetBoundingBox Parms{};

	Parms.Cells = std::move(Cells);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Bounds != nullptr)
		*Bounds = std::move(Parms.Bounds);
}


// Function DungeonArchitectRuntime.GridDungeonModelHelper.GetCellCenter
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FCell&                     Cell                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector*                         Center                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGridDungeonModelHelper::GetCellCenter(const struct FCell& Cell, struct FVector* Center)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GridDungeonModelHelper", "GetCellCenter");

	Params::GridDungeonModelHelper_GetCellCenter Parms{};

	Parms.Cell = std::move(Cell);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Center != nullptr)
		*Center = std::move(Parms.Center);
}


// Function DungeonArchitectRuntime.GridDungeonModelHelper.GetCellConnectedRooms
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FCell&                     Cell                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<int32>*                          ConnectedRooms                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UGridDungeonModelHelper::GetCellConnectedRooms(const struct FCell& Cell, TArray<int32>* ConnectedRooms)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GridDungeonModelHelper", "GetCellConnectedRooms");

	Params::GridDungeonModelHelper_GetCellConnectedRooms Parms{};

	Parms.Cell = std::move(Cell);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ConnectedRooms != nullptr)
		*ConnectedRooms = std::move(Parms.ConnectedRooms);
}


// Function DungeonArchitectRuntime.GridDungeonModelHelper.GetCellMSTRooms
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FCell&                     Cell                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<int32>*                          MSTRooms                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UGridDungeonModelHelper::GetCellMSTRooms(const struct FCell& Cell, TArray<int32>* MSTRooms)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GridDungeonModelHelper", "GetCellMSTRooms");

	Params::GridDungeonModelHelper_GetCellMSTRooms Parms{};

	Parms.Cell = std::move(Cell);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (MSTRooms != nullptr)
		*MSTRooms = std::move(Parms.MSTRooms);
}


// Function DungeonArchitectRuntime.GridDungeonModelHelper.GetDoorExits
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FCellDoor&                 Door                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector*                         ExitA                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         ExitB                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGridDungeonModelHelper::GetDoorExits(const struct FCellDoor& Door, struct FVector* ExitA, struct FVector* ExitB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GridDungeonModelHelper", "GetDoorExits");

	Params::GridDungeonModelHelper_GetDoorExits Parms{};

	Parms.Door = std::move(Door);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ExitA != nullptr)
		*ExitA = std::move(Parms.ExitA);

	if (ExitB != nullptr)
		*ExitB = std::move(Parms.ExitB);
}


// Function DungeonArchitectRuntime.GridDungeonModelHelper.GetRandomCellLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UGridDungeonModel*                Model                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGridDungeonConfig*               Config                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UGridDungeonModelHelper::GetRandomCellLocation(class UGridDungeonModel* Model, class UGridDungeonConfig* Config)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GridDungeonModelHelper", "GetRandomCellLocation");

	Params::GridDungeonModelHelper_GetRandomCellLocation Parms{};

	Parms.Model = Model;
	Parms.Config = Config;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonArchitectRuntime.GridDungeonModelHelper.GetRoomFreeEdge
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGridDungeonModel*                Model                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCell&                     RoomCell                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FVector>*                 FreeEdgeCenters                                        (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<float>*                          FreeEdgeAngles                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UGridDungeonModelHelper::GetRoomFreeEdge(class UGridDungeonModel* Model, const struct FCell& RoomCell, TArray<struct FVector>* FreeEdgeCenters, TArray<float>* FreeEdgeAngles)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GridDungeonModelHelper", "GetRoomFreeEdge");

	Params::GridDungeonModelHelper_GetRoomFreeEdge Parms{};

	Parms.Model = Model;
	Parms.RoomCell = std::move(RoomCell);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (FreeEdgeCenters != nullptr)
		*FreeEdgeCenters = std::move(Parms.FreeEdgeCenters);

	if (FreeEdgeAngles != nullptr)
		*FreeEdgeAngles = std::move(Parms.FreeEdgeAngles);
}


// Function DungeonArchitectRuntime.GridDungeonModelHelper.RemovePaintCell
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGridToolPaintStrokeData&  CellData                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class ADungeon*                         Dungeon                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutomaticRebuild                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGridDungeonModelHelper::RemovePaintCell(const struct FGridToolPaintStrokeData& CellData, class ADungeon* Dungeon, bool bAutomaticRebuild)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GridDungeonModelHelper", "RemovePaintCell");

	Params::GridDungeonModelHelper_RemovePaintCell Parms{};

	Parms.CellData = std::move(CellData);
	Parms.Dungeon = Dungeon;
	Parms.bAutomaticRebuild = bAutomaticRebuild;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonArchitectRuntime.GridDungeonModelHelper.ToWorldCoords
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FRectangle&                Bounds                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FVector&                   GridSize                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         Location                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         Size                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGridDungeonModelHelper::ToWorldCoords(const struct FRectangle& Bounds, const struct FVector& GridSize, struct FVector* Location, struct FVector* Size)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GridDungeonModelHelper", "ToWorldCoords");

	Params::GridDungeonModelHelper_ToWorldCoords Parms{};

	Parms.Bounds = std::move(Bounds);
	Parms.GridSize = std::move(GridSize);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Location != nullptr)
		*Location = std::move(Parms.Location);

	if (Size != nullptr)
		*Size = std::move(Parms.Size);
}


// Function DungeonArchitectRuntime.GridDungeonQuery.ContainsDoorBetween
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   CellA                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CellB                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGridDungeonQuery::ContainsDoorBetween(int32 CellA, int32 CellB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridDungeonQuery", "ContainsDoorBetween");

	Params::GridDungeonQuery_ContainsDoorBetween Parms{};

	Parms.CellA = CellA;
	Parms.CellB = CellB;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonArchitectRuntime.GridDungeonQuery.ContainsStairBetween
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   CellA                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CellB                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGridDungeonQuery::ContainsStairBetween(int32 CellA, int32 CellB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridDungeonQuery", "ContainsStairBetween");

	Params::GridDungeonQuery_ContainsStairBetween Parms{};

	Parms.CellA = CellA;
	Parms.CellB = CellB;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonArchitectRuntime.GridDungeonQuery.GetAdjacentCells
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   CellId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>*                          OutAdjacentCells                                       (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UGridDungeonQuery::GetAdjacentCells(int32 CellId, TArray<int32>* OutAdjacentCells)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridDungeonQuery", "GetAdjacentCells");

	Params::GridDungeonQuery_GetAdjacentCells Parms{};

	Parms.CellId = CellId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutAdjacentCells != nullptr)
		*OutAdjacentCells = std::move(Parms.OutAdjacentCells);
}


// Function DungeonArchitectRuntime.GridDungeonQuery.GetAdjacentCellsOnEdge
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FTransform&                WallMarkerTransform                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// int32*                                  CellA                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  CellB                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGridDungeonQuery::GetAdjacentCellsOnEdge(const struct FTransform& WallMarkerTransform, int32* CellA, int32* CellB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridDungeonQuery", "GetAdjacentCellsOnEdge");

	Params::GridDungeonQuery_GetAdjacentCellsOnEdge Parms{};

	Parms.WallMarkerTransform = std::move(WallMarkerTransform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (CellA != nullptr)
		*CellA = Parms.CellA;

	if (CellB != nullptr)
		*CellB = Parms.CellB;
}


// Function DungeonArchitectRuntime.GridDungeonQuery.GetCellAtLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   WorldLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  OutCellId                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bOutValid                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGridDungeonQuery::GetCellAtLocation(const struct FVector& WorldLocation, int32* OutCellId, bool* bOutValid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridDungeonQuery", "GetCellAtLocation");

	Params::GridDungeonQuery_GetCellAtLocation Parms{};

	Parms.WorldLocation = std::move(WorldLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutCellId != nullptr)
		*OutCellId = Parms.OutCellId;

	if (bOutValid != nullptr)
		*bOutValid = Parms.bOutValid;
}


// Function DungeonArchitectRuntime.GridDungeonQuery.GetCellDimension
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   CellId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         OutCenter                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         OutSize                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGridDungeonQuery::GetCellDimension(int32 CellId, struct FVector* OutCenter, struct FVector* OutSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridDungeonQuery", "GetCellDimension");

	Params::GridDungeonQuery_GetCellDimension Parms{};

	Parms.CellId = CellId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutCenter != nullptr)
		*OutCenter = std::move(Parms.OutCenter);

	if (OutSize != nullptr)
		*OutSize = std::move(Parms.OutSize);
}


// Function DungeonArchitectRuntime.GridDungeonQuery.GetCells
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<int32>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<int32> UGridDungeonQuery::GetCells()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridDungeonQuery", "GetCells");

	Params::GridDungeonQuery_GetCells Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonArchitectRuntime.GridDungeonQuery.GetCellsOfType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EFCellType                              CellType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<int32> UGridDungeonQuery::GetCellsOfType(EFCellType CellType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridDungeonQuery", "GetCellsOfType");

	Params::GridDungeonQuery_GetCellsOfType Parms{};

	Parms.CellType = CellType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonArchitectRuntime.GridDungeonQuery.GetCellType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   CellId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EFCellType                              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EFCellType UGridDungeonQuery::GetCellType(int32 CellId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridDungeonQuery", "GetCellType");

	Params::GridDungeonQuery_GetCellType Parms{};

	Parms.CellId = CellId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonArchitectRuntime.GridDungeonQuery.GetDoorBetween
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   CellA                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CellB                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCellDoor                        ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FCellDoor UGridDungeonQuery::GetDoorBetween(int32 CellA, int32 CellB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridDungeonQuery", "GetDoorBetween");

	Params::GridDungeonQuery_GetDoorBetween Parms{};

	Parms.CellA = CellA;
	Parms.CellB = CellB;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonArchitectRuntime.GridDungeonQuery.GetFurthestRooms
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// int32*                                  OutRoomA                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  OutRoomB                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGridDungeonQuery::GetFurthestRooms(int32* OutRoomA, int32* OutRoomB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridDungeonQuery", "GetFurthestRooms");

	Params::GridDungeonQuery_GetFurthestRooms Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRoomA != nullptr)
		*OutRoomA = Parms.OutRoomA;

	if (OutRoomB != nullptr)
		*OutRoomB = Parms.OutRoomB;
}


// Function DungeonArchitectRuntime.GridDungeonQuery.GetOpeningPointBetweenAdjacentCells
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   CellA                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CellB                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UGridDungeonQuery::GetOpeningPointBetweenAdjacentCells(int32 CellA, int32 CellB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridDungeonQuery", "GetOpeningPointBetweenAdjacentCells");

	Params::GridDungeonQuery_GetOpeningPointBetweenAdjacentCells Parms{};

	Parms.CellA = CellA;
	Parms.CellB = CellB;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonArchitectRuntime.GridDungeonQuery.GetPathBetweenCells
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   CellA                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CellB                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>*                          OutResult                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool*                                   bOutSuccess                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGridDungeonQuery::GetPathBetweenCells(int32 CellA, int32 CellB, TArray<int32>* OutResult, bool* bOutSuccess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridDungeonQuery", "GetPathBetweenCells");

	Params::GridDungeonQuery_GetPathBetweenCells Parms{};

	Parms.CellA = CellA;
	Parms.CellB = CellB;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutResult != nullptr)
		*OutResult = std::move(Parms.OutResult);

	if (bOutSuccess != nullptr)
		*bOutSuccess = Parms.bOutSuccess;
}


// Function DungeonArchitectRuntime.GridDungeonQuery.GetRandomCell
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGridDungeonQuery::GetRandomCell()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridDungeonQuery", "GetRandomCell");

	Params::GridDungeonQuery_GetRandomCell Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonArchitectRuntime.GridDungeonQuery.GetRandomCellFromStream
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRandomStream*                   RandomStream                                           (Parm, OutParm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGridDungeonQuery::GetRandomCellFromStream(struct FRandomStream* RandomStream)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridDungeonQuery", "GetRandomCellFromStream");

	Params::GridDungeonQuery_GetRandomCellFromStream Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (RandomStream != nullptr)
		*RandomStream = std::move(Parms.RandomStream);

	return Parms.ReturnValue;
}


// Function DungeonArchitectRuntime.GridDungeonQuery.GetRandomCellOfType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EFCellType                              CellType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGridDungeonQuery::GetRandomCellOfType(EFCellType CellType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridDungeonQuery", "GetRandomCellOfType");

	Params::GridDungeonQuery_GetRandomCellOfType Parms{};

	Parms.CellType = CellType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonArchitectRuntime.GridDungeonQuery.GetRandomCellOfTypeFromStream
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// EFCellType                              CellType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRandomStream*                   RandomStream                                           (Parm, OutParm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGridDungeonQuery::GetRandomCellOfTypeFromStream(EFCellType CellType, struct FRandomStream* RandomStream)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridDungeonQuery", "GetRandomCellOfTypeFromStream");

	Params::GridDungeonQuery_GetRandomCellOfTypeFromStream Parms{};

	Parms.CellType = CellType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (RandomStream != nullptr)
		*RandomStream = std::move(Parms.RandomStream);

	return Parms.ReturnValue;
}


// Function DungeonArchitectRuntime.GridDungeonQuery.GetStairBetween
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   CellA                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CellB                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FStairInfo                       ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FStairInfo UGridDungeonQuery::GetStairBetween(int32 CellA, int32 CellB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridDungeonQuery", "GetStairBetween");

	Params::GridDungeonQuery_GetStairBetween Parms{};

	Parms.CellA = CellA;
	Parms.CellB = CellB;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonArchitectRuntime.GridDungeonQuery.IsNearMarker
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FTransform&                CurrentMarkerTransform                                 (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// const class FString&                    NearbyMarkerName                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NearbyDistance                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDungeonBuilder*                  Builder                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bIsNear                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  NumFound                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGridDungeonQuery::IsNearMarker(const struct FTransform& CurrentMarkerTransform, const class FString& NearbyMarkerName, float NearbyDistance, class UDungeonBuilder* Builder, bool* bIsNear, int32* NumFound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridDungeonQuery", "IsNearMarker");

	Params::GridDungeonQuery_IsNearMarker Parms{};

	Parms.CurrentMarkerTransform = std::move(CurrentMarkerTransform);
	Parms.NearbyMarkerName = std::move(NearbyMarkerName);
	Parms.NearbyDistance = NearbyDistance;
	Parms.Builder = Builder;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bIsNear != nullptr)
		*bIsNear = Parms.bIsNear;

	if (NumFound != nullptr)
		*NumFound = Parms.NumFound;
}


// Function DungeonArchitectRuntime.GridDungeonSelectorLogic.ContainsStair
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UGridDungeonModel*                Model                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCell&                     Cell                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   GridX                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   GridY                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGridDungeonSelectorLogic::ContainsStair(class UGridDungeonModel* Model, const struct FCell& Cell, int32 GridX, int32 GridY)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridDungeonSelectorLogic", "ContainsStair");

	Params::GridDungeonSelectorLogic_ContainsStair Parms{};

	Parms.Model = Model;
	Parms.Cell = std::move(Cell);
	Parms.GridX = GridX;
	Parms.GridY = GridY;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonArchitectRuntime.GridDungeonSelectorLogic.IsOnCorner
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGridDungeonModel*                Model                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   GridX                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   GridY                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGridDungeonSelectorLogic::IsOnCorner(class UGridDungeonModel* Model, int32 GridX, int32 GridY)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridDungeonSelectorLogic", "IsOnCorner");

	Params::GridDungeonSelectorLogic_IsOnCorner Parms{};

	Parms.Model = Model;
	Parms.GridX = GridX;
	Parms.GridY = GridY;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonArchitectRuntime.GridDungeonSelectorLogic.IsPassageTooNarrow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGridDungeonModel*                Model                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   GridX                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   GridY                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGridDungeonSelectorLogic::IsPassageTooNarrow(class UGridDungeonModel* Model, int32 GridX, int32 GridY)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridDungeonSelectorLogic", "IsPassageTooNarrow");

	Params::GridDungeonSelectorLogic_IsPassageTooNarrow Parms{};

	Parms.Model = Model;
	Parms.GridX = GridX;
	Parms.GridY = GridY;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonArchitectRuntime.GridDungeonSelectorLogic.IsPillarOnCorner
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UGridDungeonModel*                Model                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   GridX                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   GridY                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform*                      OutCornerOffset                                        (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGridDungeonSelectorLogic::IsPillarOnCorner(class UGridDungeonModel* Model, int32 GridX, int32 GridY, struct FTransform* OutCornerOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridDungeonSelectorLogic", "IsPillarOnCorner");

	Params::GridDungeonSelectorLogic_IsPillarOnCorner Parms{};

	Parms.Model = Model;
	Parms.GridX = GridX;
	Parms.GridY = GridY;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutCornerOffset != nullptr)
		*OutCornerOffset = std::move(Parms.OutCornerOffset);

	return Parms.ReturnValue;
}


// Function DungeonArchitectRuntime.GridDungeonSelectorLogic.SelectNode
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// class UGridDungeonModel*                Model                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGridDungeonConfig*               Config                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGridDungeonBuilder*              Builder                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGridDungeonQuery*                Query                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCell&                     Cell                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FRandomStream&             RandomStream                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   GridX                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   GridY                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                MarkerTransform                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGridDungeonSelectorLogic::SelectNode(class UGridDungeonModel* Model, class UGridDungeonConfig* Config, class UGridDungeonBuilder* Builder, class UGridDungeonQuery* Query, const struct FCell& Cell, const struct FRandomStream& RandomStream, int32 GridX, int32 GridY, const struct FTransform& MarkerTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridDungeonSelectorLogic", "SelectNode");

	Params::GridDungeonSelectorLogic_SelectNode Parms{};

	Parms.Model = Model;
	Parms.Config = Config;
	Parms.Builder = Builder;
	Parms.Query = Query;
	Parms.Cell = std::move(Cell);
	Parms.RandomStream = std::move(RandomStream);
	Parms.GridX = GridX;
	Parms.GridY = GridY;
	Parms.MarkerTransform = std::move(MarkerTransform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonArchitectRuntime.GridDungeonTransformLogic.GetNodeOffset
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// class UGridDungeonModel*                Model                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGridDungeonConfig*               Config                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGridDungeonBuilder*              Builder                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGridDungeonQuery*                Query                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCell&                     Cell                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FRandomStream&             RandomStream                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   GridX                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   GridY                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                MarkerTransform                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FTransform*                      Offset                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UGridDungeonTransformLogic::GetNodeOffset(class UGridDungeonModel* Model, class UGridDungeonConfig* Config, class UGridDungeonBuilder* Builder, class UGridDungeonQuery* Query, const struct FCell& Cell, const struct FRandomStream& RandomStream, int32 GridX, int32 GridY, const struct FTransform& MarkerTransform, struct FTransform* Offset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridDungeonTransformLogic", "GetNodeOffset");

	Params::GridDungeonTransformLogic_GetNodeOffset Parms{};

	Parms.Model = Model;
	Parms.Config = Config;
	Parms.Builder = Builder;
	Parms.Query = Query;
	Parms.Cell = std::move(Cell);
	Parms.RandomStream = std::move(RandomStream);
	Parms.GridX = GridX;
	Parms.GridY = GridY;
	Parms.MarkerTransform = std::move(MarkerTransform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Offset != nullptr)
		*Offset = std::move(Parms.Offset);
}


// Function DungeonArchitectRuntime.GridFlowQuery.GetChunkAtLayoutNode
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UFlowAbstractNode*          InLayoutNode                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGridFlowChunkQueryResult*       Result                                                 (Parm, OutParm, NativeAccessSpecifierPublic)

void UGridFlowQuery::GetChunkAtLayoutNode(const class UFlowAbstractNode* InLayoutNode, struct FGridFlowChunkQueryResult* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GridFlowQuery", "GetChunkAtLayoutNode");

	Params::GridFlowQuery_GetChunkAtLayoutNode Parms{};

	Parms.InLayoutNode = InLayoutNode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = std::move(Parms.Result);
}


// Function DungeonArchitectRuntime.GridFlowQuery.IsNearMarker
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FTransform&                CurrentMarkerTransform                                 (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// const class FString&                    NearbyMarkerName                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NearbyDistance                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDungeonBuilder*                  Builder                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bIsNear                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  NumFound                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGridFlowQuery::IsNearMarker(const struct FTransform& CurrentMarkerTransform, const class FString& NearbyMarkerName, float NearbyDistance, class UDungeonBuilder* Builder, bool* bIsNear, int32* NumFound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GridFlowQuery", "IsNearMarker");

	Params::GridFlowQuery_IsNearMarker Parms{};

	Parms.CurrentMarkerTransform = std::move(CurrentMarkerTransform);
	Parms.NearbyMarkerName = std::move(NearbyMarkerName);
	Parms.NearbyDistance = NearbyDistance;
	Parms.Builder = Builder;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bIsNear != nullptr)
		*bIsNear = Parms.bIsNear;

	if (NumFound != nullptr)
		*NumFound = Parms.NumFound;
}


// Function DungeonArchitectRuntime.GridFlowQuery.ConvertTileToWorldCoord
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   TileCoord                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UGridFlowQuery::ConvertTileToWorldCoord(const struct FVector& TileCoord)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridFlowQuery", "ConvertTileToWorldCoord");

	Params::GridFlowQuery_ConvertTileToWorldCoord Parms{};

	Parms.TileCoord = std::move(TileCoord);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonArchitectRuntime.GridFlowQuery.ConvertWorldToTileCoord
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   WorldCoords                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UGridFlowQuery::ConvertWorldToTileCoord(const struct FVector& WorldCoords)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridFlowQuery", "ConvertWorldToTileCoord");

	Params::GridFlowQuery_ConvertWorldToTileCoord Parms{};

	Parms.WorldCoords = std::move(WorldCoords);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonArchitectRuntime.GridFlowQuery.GetCellAtTileCoord
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   TileCoord                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGridFlowTilemapCell*            OutCell                                                (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGridFlowQuery::GetCellAtTileCoord(const struct FVector& TileCoord, struct FGridFlowTilemapCell* OutCell)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridFlowQuery", "GetCellAtTileCoord");

	Params::GridFlowQuery_GetCellAtTileCoord Parms{};

	Parms.TileCoord = std::move(TileCoord);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutCell != nullptr)
		*OutCell = std::move(Parms.OutCell);

	return Parms.ReturnValue;
}


// Function DungeonArchitectRuntime.GridFlowQuery.GetCellAtWorldCoord
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   WorldCoord                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGridFlowTilemapCell*            OutCell                                                (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGridFlowQuery::GetCellAtWorldCoord(const struct FVector& WorldCoord, struct FGridFlowTilemapCell* OutCell)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridFlowQuery", "GetCellAtWorldCoord");

	Params::GridFlowQuery_GetCellAtWorldCoord Parms{};

	Parms.WorldCoord = std::move(WorldCoord);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutCell != nullptr)
		*OutCell = std::move(Parms.OutCell);

	return Parms.ReturnValue;
}


// Function DungeonArchitectRuntime.GridFlowQuery.GetCellRoomType
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   WorldCoord                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGridFlowAbstractNodeRoomType*          OutRoomType                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGridFlowQuery::GetCellRoomType(const struct FVector& WorldCoord, EGridFlowAbstractNodeRoomType* OutRoomType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridFlowQuery", "GetCellRoomType");

	Params::GridFlowQuery_GetCellRoomType Parms{};

	Parms.WorldCoord = std::move(WorldCoord);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRoomType != nullptr)
		*OutRoomType = Parms.OutRoomType;

	return Parms.ReturnValue;
}


// Function DungeonArchitectRuntime.GridFlowQuery.GetChunkAtWorldCoord
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   InWorldCoord                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGridFlowChunkQueryResult*       Result                                                 (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGridFlowQuery::GetChunkAtWorldCoord(const struct FVector& InWorldCoord, struct FGridFlowChunkQueryResult* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridFlowQuery", "GetChunkAtWorldCoord");

	Params::GridFlowQuery_GetChunkAtWorldCoord Parms{};

	Parms.InWorldCoord = std::move(InWorldCoord);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = std::move(Parms.Result);

	return Parms.ReturnValue;
}


// Function DungeonArchitectRuntime.GridFlowQuery.GetFreeTileLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<EGridFlowAbstractNodeRoomType>&AllowedRoomTypes                                       (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// const struct FRandomStream&             Random                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool*                                   OutSuccess                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         OutWorldCoord                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGridFlowQuery::GetFreeTileLocation(const TArray<EGridFlowAbstractNodeRoomType>& AllowedRoomTypes, const struct FRandomStream& Random, bool* OutSuccess, struct FVector* OutWorldCoord)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridFlowQuery", "GetFreeTileLocation");

	Params::GridFlowQuery_GetFreeTileLocation Parms{};

	Parms.AllowedRoomTypes = std::move(AllowedRoomTypes);
	Parms.Random = std::move(Random);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSuccess != nullptr)
		*OutSuccess = Parms.OutSuccess;

	if (OutWorldCoord != nullptr)
		*OutWorldCoord = std::move(Parms.OutWorldCoord);
}


// Function DungeonArchitectRuntime.GridFlowQuery.GetAllChunksOfType
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EGridFlowAbstractNodeRoomType           RoomType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FGridFlowChunkQueryResult>*OutChunks                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UGridFlowQuery::GetAllChunksOfType(EGridFlowAbstractNodeRoomType RoomType, TArray<struct FGridFlowChunkQueryResult>* OutChunks) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridFlowQuery", "GetAllChunksOfType");

	Params::GridFlowQuery_GetAllChunksOfType Parms{};

	Parms.RoomType = RoomType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutChunks != nullptr)
		*OutChunks = std::move(Parms.OutChunks);
}


// Function DungeonArchitectRuntime.GridFlowQuery.GetChunkAtLayoutNodeCoord
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector&                   InLayoutNodeCoord                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGridFlowChunkQueryResult*       Result                                                 (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGridFlowQuery::GetChunkAtLayoutNodeCoord(const struct FVector& InLayoutNodeCoord, struct FGridFlowChunkQueryResult* Result) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridFlowQuery", "GetChunkAtLayoutNodeCoord");

	Params::GridFlowQuery_GetChunkAtLayoutNodeCoord Parms{};

	Parms.InLayoutNodeCoord = std::move(InLayoutNodeCoord);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = std::move(Parms.Result);

	return Parms.ReturnValue;
}


// Function DungeonArchitectRuntime.GridFlowSelectorLogic.SelectNode
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// class UGridFlowModel*                   Model                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGridFlowConfig*                  Config                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGridFlowBuilder*                 Builder                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGridFlowQuery*                   Query                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRandomStream&             RandomStream                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   TileX                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TileY                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                MarkerTransform                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGridFlowSelectorLogic::SelectNode(class UGridFlowModel* Model, class UGridFlowConfig* Config, class UGridFlowBuilder* Builder, class UGridFlowQuery* Query, const struct FRandomStream& RandomStream, int32 TileX, int32 TileY, const struct FTransform& MarkerTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridFlowSelectorLogic", "SelectNode");

	Params::GridFlowSelectorLogic_SelectNode Parms{};

	Parms.Model = Model;
	Parms.Config = Config;
	Parms.Builder = Builder;
	Parms.Query = Query;
	Parms.RandomStream = std::move(RandomStream);
	Parms.TileX = TileX;
	Parms.TileY = TileY;
	Parms.MarkerTransform = std::move(MarkerTransform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonArchitectRuntime.GridFlowTransformLogic.GetNodeOffset
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// class UGridFlowModel*                   Model                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGridFlowConfig*                  Config                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGridFlowQuery*                   Query                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRandomStream&             RandomStream                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   GridX                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   GridY                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform*                      Offset                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UGridFlowTransformLogic::GetNodeOffset(class UGridFlowModel* Model, class UGridFlowConfig* Config, class UGridFlowQuery* Query, const struct FRandomStream& RandomStream, int32 GridX, int32 GridY, struct FTransform* Offset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridFlowTransformLogic", "GetNodeOffset");

	Params::GridFlowTransformLogic_GetNodeOffset Parms{};

	Parms.Model = Model;
	Parms.Config = Config;
	Parms.Query = Query;
	Parms.RandomStream = std::move(RandomStream);
	Parms.GridX = GridX;
	Parms.GridY = GridY;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Offset != nullptr)
		*Offset = std::move(Parms.Offset);
}


// Function DungeonArchitectRuntime.IsaacDungeonModel.RemoveStylingFromRoom
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   RoomId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIsaacDungeonModel::RemoveStylingFromRoom(int32 RoomId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IsaacDungeonModel", "RemoveStylingFromRoom");

	Params::IsaacDungeonModel_RemoveStylingFromRoom Parms{};

	Parms.RoomId = RoomId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonArchitectRuntime.IsaacDungeonQuery.ContainsDoorBetween
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   RoomAId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RoomBId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIsaacDungeonQuery::ContainsDoorBetween(int32 RoomAId, int32 RoomBId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IsaacDungeonQuery", "ContainsDoorBetween");

	Params::IsaacDungeonQuery_ContainsDoorBetween Parms{};

	Parms.RoomAId = RoomAId;
	Parms.RoomBId = RoomBId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonArchitectRuntime.IsaacDungeonQuery.GetFurthestRooms
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// int32*                                  OutRoomA                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  OutRoomB                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIsaacDungeonQuery::GetFurthestRooms(int32* OutRoomA, int32* OutRoomB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IsaacDungeonQuery", "GetFurthestRooms");

	Params::IsaacDungeonQuery_GetFurthestRooms Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRoomA != nullptr)
		*OutRoomA = Parms.OutRoomA;

	if (OutRoomB != nullptr)
		*OutRoomB = Parms.OutRoomB;
}


// Function DungeonArchitectRuntime.IsaacDungeonQuery.GetRandomValidPlatform
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UIsaacDungeonQuery::GetRandomValidPlatform()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IsaacDungeonQuery", "GetRandomValidPlatform");

	Params::IsaacDungeonQuery_GetRandomValidPlatform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonArchitectRuntime.IsaacDungeonQuery.GetRoom
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   RoomId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIsaacRoom                       ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FIsaacRoom UIsaacDungeonQuery::GetRoom(int32 RoomId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IsaacDungeonQuery", "GetRoom");

	Params::IsaacDungeonQuery_GetRoom Parms{};

	Parms.RoomId = RoomId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonArchitectRuntime.IsaacDungeonQuery.GetValidPlatformOnRoom
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   RoomId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UIsaacDungeonQuery::GetValidPlatformOnRoom(int32 RoomId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IsaacDungeonQuery", "GetValidPlatformOnRoom");

	Params::IsaacDungeonQuery_GetValidPlatformOnRoom Parms{};

	Parms.RoomId = RoomId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonArchitectRuntime.IsaacDungeonSelectorLogic.SelectNode
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UIsaacDungeonModel*               Model                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIsaacDungeonSelectorLogic::SelectNode(class UIsaacDungeonModel* Model)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IsaacDungeonSelectorLogic", "SelectNode");

	Params::IsaacDungeonSelectorLogic_SelectNode Parms{};

	Parms.Model = Model;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonArchitectRuntime.IsaacDungeonTransformLogic.GetNodeOffset
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// class UIsaacDungeonModel*               Model                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform*                      Offset                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UIsaacDungeonTransformLogic::GetNodeOffset(class UIsaacDungeonModel* Model, struct FTransform* Offset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IsaacDungeonTransformLogic", "GetNodeOffset");

	Params::IsaacDungeonTransformLogic_GetNodeOffset Parms{};

	Parms.Model = Model;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Offset != nullptr)
		*Offset = std::move(Parms.Offset);
}


// Function DungeonArchitectRuntime.SimpleCitySelectorLogic.SelectNode
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class USimpleCityModel*                 Model                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USimpleCitySelectorLogic::SelectNode(class USimpleCityModel* Model)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SimpleCitySelectorLogic", "SelectNode");

	Params::SimpleCitySelectorLogic_SelectNode Parms{};

	Parms.Model = Model;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonArchitectRuntime.SimpleCityTransformLogic.GetNodeOffset
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// class USimpleCityModel*                 Model                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform*                      Offset                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void USimpleCityTransformLogic::GetNodeOffset(class USimpleCityModel* Model, struct FTransform* Offset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SimpleCityTransformLogic", "GetNodeOffset");

	Params::SimpleCityTransformLogic_GetNodeOffset Parms{};

	Parms.Model = Model;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Offset != nullptr)
		*Offset = std::move(Parms.Offset);
}


// Function DungeonArchitectRuntime.SnapSerializable.OnSnapDataLoaded
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ISnapSerializable::OnSnapDataLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("SnapSerializable", "OnSnapDataLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonArchitectRuntime.SnapConnectionActor.GetSpawnedInstances
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> ASnapConnectionActor::GetSpawnedInstances() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SnapConnectionActor", "GetSpawnedInstances");

	Params::SnapConnectionActor_GetSpawnedInstances Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonArchitectRuntime.SnapFlowNodeCategorySelectionOverride.TryOverrideCategories
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// int32                                   PathIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PathLength                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class FName>&              ExistingCategories                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class FName>*                    OutNewCategories                                       (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USnapFlowNodeCategorySelectionOverride::TryOverrideCategories(int32 PathIndex, int32 PathLength, const TArray<class FName>& ExistingCategories, TArray<class FName>* OutNewCategories)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SnapFlowNodeCategorySelectionOverride", "TryOverrideCategories");

	Params::SnapFlowNodeCategorySelectionOverride_TryOverrideCategories Parms{};

	Parms.PathIndex = PathIndex;
	Parms.PathLength = PathLength;
	Parms.ExistingCategories = std::move(ExistingCategories);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutNewCategories != nullptr)
		*OutNewCategories = std::move(Parms.OutNewCategories);

	return Parms.ReturnValue;
}

}

