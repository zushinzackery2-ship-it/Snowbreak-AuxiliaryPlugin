#pragma once

/*
* SDK generated by Rei-SdkDumper
* Based on Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GameLogicTree

#include "Basic.hpp"

#include "GameLogicTree_classes.hpp"
#include "GameLogicTree_parameters.hpp"


namespace SDK
{

// Function GameLogicTree.LogicTree_Decorator.ReCheckAndBreakChild
// (Final, Native, Public)

void ULogicTree_Decorator::ReCheckAndBreakChild()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LogicTree_Decorator", "ReCheckAndBreakChild");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameLogicTree.LogicTree_Decorator_BP.CheckCondition_BP
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULogicTree_Decorator_BP::CheckCondition_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LogicTree_Decorator_BP", "CheckCondition_BP");

	Params::LogicTree_Decorator_BP_CheckCondition_BP Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameLogicTree.LogicTree_EntityDataCom.AddData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BaseValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bReplicated                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULogicTree_EntityDataCom::AddData(class FName Name_0, float BaseValue, bool bReplicated)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LogicTree_EntityDataCom", "AddData");

	Params::LogicTree_EntityDataCom_AddData Parms{};

	Parms.Name_0 = Name_0;
	Parms.BaseValue = BaseValue;
	Parms.bReplicated = bReplicated;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameLogicTree.LogicTree_EntityDataCom.AddTag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULogicTree_EntityDataCom::AddTag(const struct FGameplayTag& Tag, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LogicTree_EntityDataCom", "AddTag");

	Params::LogicTree_EntityDataCom_AddTag Parms{};

	Parms.Tag = std::move(Tag);
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameLogicTree.LogicTree_EntityDataCom.GetBaseData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULogicTree_EntityDataCom::GetBaseData(class FName Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LogicTree_EntityDataCom", "GetBaseData");

	Params::LogicTree_EntityDataCom_GetBaseData Parms{};

	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameLogicTree.LogicTree_EntityDataCom.GetCurData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULogicTree_EntityDataCom::GetCurData(class FName Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LogicTree_EntityDataCom", "GetCurData");

	Params::LogicTree_EntityDataCom_GetCurData Parms{};

	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameLogicTree.LogicTree_EntityDataCom.IsPosInLagAABB
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   InCheckPos                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULogicTree_EntityDataCom::IsPosInLagAABB(const struct FVector& InCheckPos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LogicTree_EntityDataCom", "IsPosInLagAABB");

	Params::LogicTree_EntityDataCom_IsPosInLagAABB Parms{};

	Parms.InCheckPos = std::move(InCheckPos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameLogicTree.LogicTree_EntityDataCom.OnRep_Data
// (Final, Native, Public)

void ULogicTree_EntityDataCom::OnRep_Data()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LogicTree_EntityDataCom", "OnRep_Data");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameLogicTree.LogicTree_EntityDataCom.OnRep_ReplicatedTags
// (Final, Native, Public)

void ULogicTree_EntityDataCom::OnRep_ReplicatedTags()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LogicTree_EntityDataCom", "OnRep_ReplicatedTags");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameLogicTree.LogicTree_EntityDataCom.RegisterTagChangeCallback
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TDelegate<void(const struct FGameplayTag& Tag, bool IsContain)>&Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ULogicTree_EntityDataCom::RegisterTagChangeCallback(const struct FGameplayTag& Tag, const TDelegate<void(const struct FGameplayTag& Tag, bool IsContain)>& Callback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LogicTree_EntityDataCom", "RegisterTagChangeCallback");

	Params::LogicTree_EntityDataCom_RegisterTagChangeCallback Parms{};

	Parms.Tag = std::move(Tag);
	Parms.Callback = Callback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameLogicTree.LogicTree_EntityDataCom.RemoveTag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULogicTree_EntityDataCom::RemoveTag(const struct FGameplayTag& Tag, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LogicTree_EntityDataCom", "RemoveTag");

	Params::LogicTree_EntityDataCom_RemoveTag Parms{};

	Parms.Tag = std::move(Tag);
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameLogicTree.LogicTree_EntityDataCom.SetBaseData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULogicTree_EntityDataCom::SetBaseData(class FName Name_0, float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LogicTree_EntityDataCom", "SetBaseData");

	Params::LogicTree_EntityDataCom_SetBaseData Parms{};

	Parms.Name_0 = Name_0;
	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameLogicTree.LogicTree_EntityDataCom.SetCurrentData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULogicTree_EntityDataCom::SetCurrentData(class FName Name_0, float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LogicTree_EntityDataCom", "SetCurrentData");

	Params::LogicTree_EntityDataCom_SetCurrentData Parms{};

	Parms.Name_0 = Name_0;
	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameLogicTree.LogicTree_EntityDataCom.UnregisterTagChangeCallback
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          BoundObject                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             FunctionName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULogicTree_EntityDataCom::UnregisterTagChangeCallback(const struct FGameplayTag& Tag, class UObject* BoundObject, class FName FunctionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LogicTree_EntityDataCom", "UnregisterTagChangeCallback");

	Params::LogicTree_EntityDataCom_UnregisterTagChangeCallback Parms{};

	Parms.Tag = std::move(Tag);
	Parms.BoundObject = BoundObject;
	Parms.FunctionName = FunctionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameLogicTree.LogicTree_EntityDataCom.GetData
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OutBase                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OutCurrent                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULogicTree_EntityDataCom::GetData(class FName Name_0, float* OutBase, float* OutCurrent) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LogicTree_EntityDataCom", "GetData");

	Params::LogicTree_EntityDataCom_GetData Parms{};

	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutBase != nullptr)
		*OutBase = Parms.OutBase;

	if (OutCurrent != nullptr)
		*OutCurrent = Parms.OutCurrent;

	return Parms.ReturnValue;
}


// Function GameLogicTree.LogicTree_EntityDataCom.HasTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULogicTree_EntityDataCom::HasTag(const struct FGameplayTag& Tag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LogicTree_EntityDataCom", "HasTag");

	Params::LogicTree_EntityDataCom_HasTag Parms{};

	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameLogicTree.LogicTree_LogicHandleCom.Client_NotifyExecuteFail
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// int32                                   LogicId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PredictionId                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULogicTree_LogicHandleCom::Client_NotifyExecuteFail(int32 LogicId, int32 PredictionId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LogicTree_LogicHandleCom", "Client_NotifyExecuteFail");

	Params::LogicTree_LogicHandleCom_Client_NotifyExecuteFail Parms{};

	Parms.LogicId = LogicId;
	Parms.PredictionId = PredictionId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameLogicTree.LogicTree_LogicHandleCom.Client_NotifyStopFail
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// int32                                   LogicId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PredictionId                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULogicTree_LogicHandleCom::Client_NotifyStopFail(int32 LogicId, int32 PredictionId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LogicTree_LogicHandleCom", "Client_NotifyStopFail");

	Params::LogicTree_LogicHandleCom_Client_NotifyStopFail Parms{};

	Parms.LogicId = LogicId;
	Parms.PredictionId = PredictionId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameLogicTree.LogicTree_LogicHandleCom.MulticastExecuteLogic
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// int32                                   LogicId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PredictionId                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULogicTree_LogicHandleCom::MulticastExecuteLogic(int32 LogicId, int32 PredictionId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LogicTree_LogicHandleCom", "MulticastExecuteLogic");

	Params::LogicTree_LogicHandleCom_MulticastExecuteLogic Parms{};

	Parms.LogicId = LogicId;
	Parms.PredictionId = PredictionId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameLogicTree.LogicTree_LogicHandleCom.MulticastExecuteNode_FromServer
// (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable)
// Parameters:
// int32                                   LogicId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NodeId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLogicTree_NodeExecutionData&InData                                                 (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void ULogicTree_LogicHandleCom::MulticastExecuteNode_FromServer(int32 LogicId, int32 NodeId, const struct FLogicTree_NodeExecutionData& InData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LogicTree_LogicHandleCom", "MulticastExecuteNode_FromServer");

	Params::LogicTree_LogicHandleCom_MulticastExecuteNode_FromServer Parms{};

	Parms.LogicId = LogicId;
	Parms.NodeId = NodeId;
	Parms.InData = std::move(InData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameLogicTree.LogicTree_LogicHandleCom.MulticastStopLogic
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// int32                                   LogicId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PredictionId                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULogicTree_LogicHandleCom::MulticastStopLogic(int32 LogicId, int32 PredictionId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LogicTree_LogicHandleCom", "MulticastStopLogic");

	Params::LogicTree_LogicHandleCom_MulticastStopLogic Parms{};

	Parms.LogicId = LogicId;
	Parms.PredictionId = PredictionId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameLogicTree.LogicTree_LogicHandleCom.OnRep_ReplicatedHandles
// (Final, Native, Public)

void ULogicTree_LogicHandleCom::OnRep_ReplicatedHandles()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LogicTree_LogicHandleCom", "OnRep_ReplicatedHandles");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameLogicTree.LogicTree_LogicHandleCom.Server_TryStopLogic
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// int32                                   LogicId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PredictionId                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULogicTree_LogicHandleCom::Server_TryStopLogic(int32 LogicId, int32 PredictionId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LogicTree_LogicHandleCom", "Server_TryStopLogic");

	Params::LogicTree_LogicHandleCom_Server_TryStopLogic Parms{};

	Parms.LogicId = LogicId;
	Parms.PredictionId = PredictionId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameLogicTree.LogicTree_LogicHandleCom.TryExecuteLogic
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// int32                                   LogicId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PredictionId                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULogicTree_LogicHandleCom::TryExecuteLogic(int32 LogicId, int32 PredictionId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LogicTree_LogicHandleCom", "TryExecuteLogic");

	Params::LogicTree_LogicHandleCom_TryExecuteLogic Parms{};

	Parms.LogicId = LogicId;
	Parms.PredictionId = PredictionId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameLogicTree.LogicTree_LogicHandleCom.TryExecuteLogic_FromClient
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   LogicId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULogicTree_LogicHandleCom::TryExecuteLogic_FromClient(int32 LogicId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LogicTree_LogicHandleCom", "TryExecuteLogic_FromClient");

	Params::LogicTree_LogicHandleCom_TryExecuteLogic_FromClient Parms{};

	Parms.LogicId = LogicId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameLogicTree.LogicTree_LogicHandleCom.TryStopLogic_FromClient
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   LogicId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULogicTree_LogicHandleCom::TryStopLogic_FromClient(int32 LogicId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LogicTree_LogicHandleCom", "TryStopLogic_FromClient");

	Params::LogicTree_LogicHandleCom_TryStopLogic_FromClient Parms{};

	Parms.LogicId = LogicId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameLogicTree.LT_Decorator_CheckOwnerTag.OnTagChange
// (Final, Native, Public)
// Parameters:
// const struct FGameplayTag&              Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsContain                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULT_Decorator_CheckOwnerTag::OnTagChange(const struct FGameplayTag& Tag, bool IsContain)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LT_Decorator_CheckOwnerTag", "OnTagChange");

	Params::LT_Decorator_CheckOwnerTag_OnTagChange Parms{};

	Parms.Tag = std::move(Tag);
	Parms.IsContain = IsContain;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameLogicTree.GameLogicTree_EntityMgr.CheckActorHasTagByStr
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InTagStr                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameLogicTree_EntityMgr::CheckActorHasTagByStr(class AActor* TargetActor, class FName InTagStr)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameLogicTree_EntityMgr", "CheckActorHasTagByStr");

	Params::GameLogicTree_EntityMgr_CheckActorHasTagByStr Parms{};

	Parms.TargetActor = TargetActor;
	Parms.InTagStr = InTagStr;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameLogicTree.GameLogicTree_EntityMgr.Get
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameLogicTree_EntityMgr*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameLogicTree_EntityMgr* UGameLogicTree_EntityMgr::Get(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameLogicTree_EntityMgr", "Get");

	Params::GameLogicTree_EntityMgr_Get Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameLogicTree.GameLogicTree_EntityMgr.GetLTDataDataAccessorFloatData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLogicTree_DataAccessor*         InAccessor                                             (Parm, OutParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class ULogicTreeNode*                   FromNode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameLogicTree_EntityMgr::GetLTDataDataAccessorFloatData(struct FLogicTree_DataAccessor* InAccessor, class ULogicTreeNode* FromNode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameLogicTree_EntityMgr", "GetLTDataDataAccessorFloatData");

	Params::GameLogicTree_EntityMgr_GetLTDataDataAccessorFloatData Parms{};

	Parms.FromNode = FromNode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (InAccessor != nullptr)
		*InAccessor = std::move(Parms.InAccessor);

	return Parms.ReturnValue;
}


// Function GameLogicTree.GameLogicTree_EntityMgr.GetLTDataDataAccessorIntData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLogicTree_DataAccessor*         InAccessor                                             (Parm, OutParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class ULogicTreeNode*                   FromNode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameLogicTree_EntityMgr::GetLTDataDataAccessorIntData(struct FLogicTree_DataAccessor* InAccessor, class ULogicTreeNode* FromNode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameLogicTree_EntityMgr", "GetLTDataDataAccessorIntData");

	Params::GameLogicTree_EntityMgr_GetLTDataDataAccessorIntData Parms{};

	Parms.FromNode = FromNode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (InAccessor != nullptr)
		*InAccessor = std::move(Parms.InAccessor);

	return Parms.ReturnValue;
}


// Function GameLogicTree.GameLogicTree_EntityMgr.GetLTDataDataAccessorObjData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLogicTree_DataAccessor*         InAccessor                                             (Parm, OutParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class ULogicTreeNode*                   FromNode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UGameLogicTree_EntityMgr::GetLTDataDataAccessorObjData(struct FLogicTree_DataAccessor* InAccessor, class ULogicTreeNode* FromNode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameLogicTree_EntityMgr", "GetLTDataDataAccessorObjData");

	Params::GameLogicTree_EntityMgr_GetLTDataDataAccessorObjData Parms{};

	Parms.FromNode = FromNode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (InAccessor != nullptr)
		*InAccessor = std::move(Parms.InAccessor);

	return Parms.ReturnValue;
}


// Function GameLogicTree.GameLogicTree_EntityMgr.GetLTDataDataAccessorVectorData
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLogicTree_DataAccessor*         InAccessor                                             (Parm, OutParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class ULogicTreeNode*                   FromNode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UGameLogicTree_EntityMgr::GetLTDataDataAccessorVectorData(struct FLogicTree_DataAccessor* InAccessor, class ULogicTreeNode* FromNode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameLogicTree_EntityMgr", "GetLTDataDataAccessorVectorData");

	Params::GameLogicTree_EntityMgr_GetLTDataDataAccessorVectorData Parms{};

	Parms.FromNode = FromNode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (InAccessor != nullptr)
		*InAccessor = std::move(Parms.InAccessor);

	return Parms.ReturnValue;
}


// Function GameLogicTree.GameLogicTree_EntityMgr.SetLTDataDataAccessorFloatData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLogicTree_DataAccessor*         InAccessor                                             (Parm, OutParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class ULogicTreeNode*                   FromNode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameLogicTree_EntityMgr::SetLTDataDataAccessorFloatData(struct FLogicTree_DataAccessor* InAccessor, class ULogicTreeNode* FromNode, float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameLogicTree_EntityMgr", "SetLTDataDataAccessorFloatData");

	Params::GameLogicTree_EntityMgr_SetLTDataDataAccessorFloatData Parms{};

	Parms.FromNode = FromNode;
	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (InAccessor != nullptr)
		*InAccessor = std::move(Parms.InAccessor);
}


// Function GameLogicTree.GameLogicTree_EntityMgr.SetLTDataDataAccessorIntData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLogicTree_DataAccessor*         InAccessor                                             (Parm, OutParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class ULogicTreeNode*                   FromNode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameLogicTree_EntityMgr::SetLTDataDataAccessorIntData(struct FLogicTree_DataAccessor* InAccessor, class ULogicTreeNode* FromNode, int32 InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameLogicTree_EntityMgr", "SetLTDataDataAccessorIntData");

	Params::GameLogicTree_EntityMgr_SetLTDataDataAccessorIntData Parms{};

	Parms.FromNode = FromNode;
	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (InAccessor != nullptr)
		*InAccessor = std::move(Parms.InAccessor);
}


// Function GameLogicTree.GameLogicTree_EntityMgr.SetLTDataDataAccessorObjData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLogicTree_DataAccessor*         InAccessor                                             (Parm, OutParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class ULogicTreeNode*                   FromNode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameLogicTree_EntityMgr::SetLTDataDataAccessorObjData(struct FLogicTree_DataAccessor* InAccessor, class ULogicTreeNode* FromNode, class UObject* InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameLogicTree_EntityMgr", "SetLTDataDataAccessorObjData");

	Params::GameLogicTree_EntityMgr_SetLTDataDataAccessorObjData Parms{};

	Parms.FromNode = FromNode;
	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (InAccessor != nullptr)
		*InAccessor = std::move(Parms.InAccessor);
}


// Function GameLogicTree.GameLogicTree_EntityMgr.SetLTDataDataAccessorVectorData
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLogicTree_DataAccessor*         InAccessor                                             (Parm, OutParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class ULogicTreeNode*                   FromNode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameLogicTree_EntityMgr::SetLTDataDataAccessorVectorData(struct FLogicTree_DataAccessor* InAccessor, class ULogicTreeNode* FromNode, const struct FVector& InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameLogicTree_EntityMgr", "SetLTDataDataAccessorVectorData");

	Params::GameLogicTree_EntityMgr_SetLTDataDataAccessorVectorData Parms{};

	Parms.FromNode = FromNode;
	Parms.InValue = std::move(InValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (InAccessor != nullptr)
		*InAccessor = std::move(Parms.InAccessor);
}


// Function GameLogicTree.GameLogicTree_EntityMgr.Static_AddTagToActor
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag*                    InTag                                                  (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameLogicTree_EntityMgr::Static_AddTagToActor(class AActor* TargetActor, struct FGameplayTag* InTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameLogicTree_EntityMgr", "Static_AddTagToActor");

	Params::GameLogicTree_EntityMgr_Static_AddTagToActor Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (InTag != nullptr)
		*InTag = std::move(Parms.InTag);
}


// Function GameLogicTree.GameLogicTree_EntityMgr.Static_RemoveActorTag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag*                    InTag                                                  (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameLogicTree_EntityMgr::Static_RemoveActorTag(class AActor* TargetActor, struct FGameplayTag* InTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameLogicTree_EntityMgr", "Static_RemoveActorTag");

	Params::GameLogicTree_EntityMgr_Static_RemoveActorTag Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (InTag != nullptr)
		*InTag = std::move(Parms.InTag);
}


// Function GameLogicTree.GameLogicTree_EntityMgr.Static_SendLogicTreeMsgToActor
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLogicTree_MsgContext&           Msg                                                    (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGameLogicTree_EntityMgr::Static_SendLogicTreeMsgToActor(class AActor* TargetActor, struct FLogicTree_MsgContext& Msg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameLogicTree_EntityMgr", "Static_SendLogicTreeMsgToActor");

	Params::GameLogicTree_EntityMgr_Static_SendLogicTreeMsgToActor Parms{};

	Parms.TargetActor = TargetActor;
	Parms.Msg = std::move(Msg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Msg = std::move(Parms.Msg);
}


// Function GameLogicTree.GameLogicTree_EntityMgr.AddTagToActor
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag*                    InTag                                                  (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameLogicTree_EntityMgr::AddTagToActor(class AActor* TargetActor, struct FGameplayTag* InTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameLogicTree_EntityMgr", "AddTagToActor");

	Params::GameLogicTree_EntityMgr_AddTagToActor Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (InTag != nullptr)
		*InTag = std::move(Parms.InTag);
}


// Function GameLogicTree.GameLogicTree_EntityMgr.GetLogicByStrPath
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    InPath                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameLogicTreeEntity*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameLogicTreeEntity* UGameLogicTree_EntityMgr::GetLogicByStrPath(const class FString& InPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameLogicTree_EntityMgr", "GetLogicByStrPath");

	Params::GameLogicTree_EntityMgr_GetLogicByStrPath Parms{};

	Parms.InPath = std::move(InPath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameLogicTree.GameLogicTree_EntityMgr.InstallLogicTreeEntity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           OwnerActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InId                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ULogicTree_LogicHandleCom>InHandleComClass                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bReplicate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    DefaultActive                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ExecuteImmediately                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLogicTree_LogicHandle           ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FLogicTree_LogicHandle UGameLogicTree_EntityMgr::InstallLogicTreeEntity(class AActor* OwnerActor, int32 InId, TSubclassOf<class ULogicTree_LogicHandleCom> InHandleComClass, bool bReplicate, bool DefaultActive, bool ExecuteImmediately)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameLogicTree_EntityMgr", "InstallLogicTreeEntity");

	Params::GameLogicTree_EntityMgr_InstallLogicTreeEntity Parms{};

	Parms.OwnerActor = OwnerActor;
	Parms.InId = InId;
	Parms.InHandleComClass = InHandleComClass;
	Parms.bReplicate = bReplicate;
	Parms.DefaultActive = DefaultActive;
	Parms.ExecuteImmediately = ExecuteImmediately;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameLogicTree.GameLogicTree_EntityMgr.InstallLogicTreeEntityByObjPath
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           OwnerActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FSoftObjectPath&           InPath                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bReplicate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    DefaultActive                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ExecuteImmediately                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLogicTree_LogicHandle           ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FLogicTree_LogicHandle UGameLogicTree_EntityMgr::InstallLogicTreeEntityByObjPath(class AActor* OwnerActor, const struct FSoftObjectPath& InPath, bool bReplicate, bool DefaultActive, bool ExecuteImmediately)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameLogicTree_EntityMgr", "InstallLogicTreeEntityByObjPath");

	Params::GameLogicTree_EntityMgr_InstallLogicTreeEntityByObjPath Parms{};

	Parms.OwnerActor = OwnerActor;
	Parms.InPath = std::move(InPath);
	Parms.bReplicate = bReplicate;
	Parms.DefaultActive = DefaultActive;
	Parms.ExecuteImmediately = ExecuteImmediately;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameLogicTree.GameLogicTree_EntityMgr.RemoveActorTag
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag*                    InTag                                                  (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameLogicTree_EntityMgr::RemoveActorTag(class AActor* TargetActor, struct FGameplayTag* InTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameLogicTree_EntityMgr", "RemoveActorTag");

	Params::GameLogicTree_EntityMgr_RemoveActorTag Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (InTag != nullptr)
		*InTag = std::move(Parms.InTag);
}


// Function GameLogicTree.GameLogicTree_EntityMgr.SendLogicTreeMsgToActor
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLogicTree_MsgContext&           Msg                                                    (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGameLogicTree_EntityMgr::SendLogicTreeMsgToActor(class AActor* TargetActor, struct FLogicTree_MsgContext& Msg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameLogicTree_EntityMgr", "SendLogicTreeMsgToActor");

	Params::GameLogicTree_EntityMgr_SendLogicTreeMsgToActor Parms{};

	Parms.TargetActor = TargetActor;
	Parms.Msg = std::move(Msg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Msg = std::move(Parms.Msg);
}


// Function GameLogicTree.GameLogicTreeEntity.ActivateDataHandlersByTag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameLogicTreeEntity::ActivateDataHandlersByTag(const struct FGameplayTag& InTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameLogicTreeEntity", "ActivateDataHandlersByTag");

	Params::GameLogicTreeEntity_ActivateDataHandlersByTag Parms{};

	Parms.InTag = std::move(InTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameLogicTree.GameLogicTreeEntity.DeActivateDataHandlersByTag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameLogicTreeEntity::DeActivateDataHandlersByTag(const struct FGameplayTag& InTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameLogicTreeEntity", "DeActivateDataHandlersByTag");

	Params::GameLogicTreeEntity_DeActivateDataHandlersByTag Parms{};

	Parms.InTag = std::move(InTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameLogicTree.GameLogicTreeEntity.FinishLogic
// (Final, Native, Public)

void UGameLogicTreeEntity::FinishLogic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameLogicTreeEntity", "FinishLogic");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameLogicTree.GameLogicTreeEntity.OnLogicEnd
// (Final, Native, Public)

void UGameLogicTreeEntity::OnLogicEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameLogicTreeEntity", "OnLogicEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameLogicTree.GameLogicTreeEntity.RequestExecute
// (Final, Native, Public, BlueprintCallable)

void UGameLogicTreeEntity::RequestExecute()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameLogicTreeEntity", "RequestExecute");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameLogicTree.GameLogicTreeEntity.GetMessageBus
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULogicTreeMessageBus*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULogicTreeMessageBus* UGameLogicTreeEntity::GetMessageBus() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameLogicTreeEntity", "GetMessageBus");

	Params::GameLogicTreeEntity_GetMessageBus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameLogicTree.LogicTree_TaskNode_BP.ExecuteBP
// (Event, Public, BlueprintEvent)
// Parameters:
// class ULogicTree_BlackBoard*            TargetBlackBoard                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELogicTreeNodeStatus                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELogicTreeNodeStatus ULogicTree_TaskNode_BP::ExecuteBP(class ULogicTree_BlackBoard* TargetBlackBoard)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LogicTree_TaskNode_BP", "ExecuteBP");

	Params::LogicTree_TaskNode_BP_ExecuteBP Parms{};

	Parms.TargetBlackBoard = TargetBlackBoard;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameLogicTree.LT_Decorator_TriggerOnMsg.OnReceiveLogicMsg
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FLogicTree_MsgContext&     Msg                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ULT_Decorator_TriggerOnMsg::OnReceiveLogicMsg(const struct FLogicTree_MsgContext& Msg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LT_Decorator_TriggerOnMsg", "OnReceiveLogicMsg");

	Params::LT_Decorator_TriggerOnMsg_OnReceiveLogicMsg Parms{};

	Parms.Msg = std::move(Msg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}

