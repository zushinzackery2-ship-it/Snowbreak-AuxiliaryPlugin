#pragma once

/*
* SDK generated by Rei-SdkDumper
* Based on Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: MotionTrajectory

#include "Basic.hpp"

#include "MotionTrajectory_classes.hpp"
#include "MotionTrajectory_parameters.hpp"


namespace SDK
{

// Function MotionTrajectory.MotionTrajectoryComponent.SetSampleRate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Rate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMotionTrajectoryComponent::SetSampleRate(int32 Rate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MotionTrajectoryComponent", "SetSampleRate");

	Params::MotionTrajectoryComponent_SetSampleRate Parms{};

	Parms.Rate = Rate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MotionTrajectory.MotionTrajectoryComponent.GetHistory
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTrajectorySampleRange           ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FTrajectorySampleRange UMotionTrajectoryComponent::GetHistory() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MotionTrajectoryComponent", "GetHistory");

	Params::MotionTrajectoryComponent_GetHistory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MotionTrajectory.MotionTrajectoryComponent.GetTrajectory
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTrajectorySampleRange           ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FTrajectorySampleRange UMotionTrajectoryComponent::GetTrajectory() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MotionTrajectoryComponent", "GetTrajectory");

	Params::MotionTrajectoryComponent_GetTrajectory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MotionTrajectory.MotionTrajectoryComponent.GetTrajectoryWithSettings
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FMotionTrajectorySettings& Settings                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bIncludeHistory                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTrajectorySampleRange           ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FTrajectorySampleRange UMotionTrajectoryComponent::GetTrajectoryWithSettings(const struct FMotionTrajectorySettings& Settings, bool bIncludeHistory) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MotionTrajectoryComponent", "GetTrajectoryWithSettings");

	Params::MotionTrajectoryComponent_GetTrajectoryWithSettings Parms{};

	Parms.Settings = std::move(Settings);
	Parms.bIncludeHistory = bIncludeHistory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MotionTrajectory.CharacterMovementTrajectoryComponent.OnMovementUpdated
// (Final, Native, Protected, HasDefaults)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   OldLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   OldVelocity                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterMovementTrajectoryComponent::OnMovementUpdated(float DeltaSeconds, const struct FVector& OldLocation, const struct FVector& OldVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterMovementTrajectoryComponent", "OnMovementUpdated");

	Params::CharacterMovementTrajectoryComponent_OnMovementUpdated Parms{};

	Parms.DeltaSeconds = DeltaSeconds;
	Parms.OldLocation = std::move(OldLocation);
	Parms.OldVelocity = std::move(OldVelocity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MotionTrajectory.MotionTrajectoryBlueprintLibrary.ClampTrajectoryDirection
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FTrajectorySampleRange&    Trajectory                                             (Parm, NativeAccessSpecifierPublic)
// const TArray<struct FTrajectoryDirectionClamp>&Directions                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bPreserveRotation                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTrajectorySampleRange           ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FTrajectorySampleRange UMotionTrajectoryBlueprintLibrary::ClampTrajectoryDirection(const struct FTrajectorySampleRange& Trajectory, const TArray<struct FTrajectoryDirectionClamp>& Directions, bool bPreserveRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionTrajectoryBlueprintLibrary", "ClampTrajectoryDirection");

	Params::MotionTrajectoryBlueprintLibrary_ClampTrajectoryDirection Parms{};

	Parms.Trajectory = std::move(Trajectory);
	Parms.Directions = std::move(Directions);
	Parms.bPreserveRotation = bPreserveRotation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MotionTrajectory.MotionTrajectoryBlueprintLibrary.DebugDrawTrajectory
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class AActor*                     Actor                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                WorldTransform                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// const struct FTrajectorySampleRange&    Trajectory                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FLinearColor&              PredictionColor                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              HistoryColor                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TransformScale                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TransformThickness                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ArrowScale                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ArrowSize                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ArrowThickness                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMotionTrajectoryBlueprintLibrary::DebugDrawTrajectory(const class AActor* Actor, const struct FTransform& WorldTransform, const struct FTrajectorySampleRange& Trajectory, const struct FLinearColor& PredictionColor, const struct FLinearColor& HistoryColor, float TransformScale, float TransformThickness, float ArrowScale, float ArrowSize, float ArrowThickness)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionTrajectoryBlueprintLibrary", "DebugDrawTrajectory");

	Params::MotionTrajectoryBlueprintLibrary_DebugDrawTrajectory Parms{};

	Parms.Actor = Actor;
	Parms.WorldTransform = std::move(WorldTransform);
	Parms.Trajectory = std::move(Trajectory);
	Parms.PredictionColor = std::move(PredictionColor);
	Parms.HistoryColor = std::move(HistoryColor);
	Parms.TransformScale = TransformScale;
	Parms.TransformThickness = TransformThickness;
	Parms.ArrowScale = ArrowScale;
	Parms.ArrowSize = ArrowSize;
	Parms.ArrowThickness = ArrowThickness;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MotionTrajectory.MotionTrajectoryBlueprintLibrary.FlattenTrajectory2D
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FTrajectorySampleRange&    Trajectory                                             (Parm, NativeAccessSpecifierPublic)
// bool                                    PreserveSpeed                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTrajectorySampleRange           ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FTrajectorySampleRange UMotionTrajectoryBlueprintLibrary::FlattenTrajectory2D(const struct FTrajectorySampleRange& Trajectory, bool PreserveSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionTrajectoryBlueprintLibrary", "FlattenTrajectory2D");

	Params::MotionTrajectoryBlueprintLibrary_FlattenTrajectory2D Parms{};

	Parms.Trajectory = std::move(Trajectory);
	Parms.PreserveSpeed = PreserveSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MotionTrajectory.MotionTrajectoryBlueprintLibrary.GetBunkerCollisionPointWithActorFaceDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class APawn*                      Actor                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TraceHeight                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TraceHeightOffset                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ValidLengthToStart                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ValidEdgeWidth                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AngleLimit                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOnlyLeft                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBunkerCollisionPoint            ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FBunkerCollisionPoint UMotionTrajectoryBlueprintLibrary::GetBunkerCollisionPointWithActorFaceDir(const class APawn* Actor, float TraceHeight, float TraceHeightOffset, float ValidLengthToStart, float ValidEdgeWidth, float AngleLimit, bool bOnlyLeft)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionTrajectoryBlueprintLibrary", "GetBunkerCollisionPointWithActorFaceDir");

	Params::MotionTrajectoryBlueprintLibrary_GetBunkerCollisionPointWithActorFaceDir Parms{};

	Parms.Actor = Actor;
	Parms.TraceHeight = TraceHeight;
	Parms.TraceHeightOffset = TraceHeightOffset;
	Parms.ValidLengthToStart = ValidLengthToStart;
	Parms.ValidEdgeWidth = ValidEdgeWidth;
	Parms.AngleLimit = AngleLimit;
	Parms.bOnlyLeft = bOnlyLeft;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MotionTrajectory.MotionTrajectoryBlueprintLibrary.GetBunkerShootableWithActorAbove
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class APawn*                      Actor                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ValidEdgeHeight                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMotionTrajectoryBlueprintLibrary::GetBunkerShootableWithActorAbove(const class APawn* Actor, float ValidEdgeHeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionTrajectoryBlueprintLibrary", "GetBunkerShootableWithActorAbove");

	Params::MotionTrajectoryBlueprintLibrary_GetBunkerShootableWithActorAbove Parms{};

	Parms.Actor = Actor;
	Parms.ValidEdgeHeight = ValidEdgeHeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MotionTrajectory.MotionTrajectoryBlueprintLibrary.GetBunkerShootableWithActorForward
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class APawn*                      Actor                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   FaceDirection                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   MoveDirection                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ShootDirZ                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ValidEdgeWidth                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMotionTrajectoryBlueprintLibrary::GetBunkerShootableWithActorForward(const class APawn* Actor, const struct FVector& FaceDirection, const struct FVector& MoveDirection, float ShootDirZ, float ValidEdgeWidth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionTrajectoryBlueprintLibrary", "GetBunkerShootableWithActorForward");

	Params::MotionTrajectoryBlueprintLibrary_GetBunkerShootableWithActorForward Parms{};

	Parms.Actor = Actor;
	Parms.FaceDirection = std::move(FaceDirection);
	Parms.MoveDirection = std::move(MoveDirection);
	Parms.ShootDirZ = ShootDirZ;
	Parms.ValidEdgeWidth = ValidEdgeWidth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MotionTrajectory.MotionTrajectoryBlueprintLibrary.GetBunkerTrajectoryCollisionPoint
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class APawn*                      Actor                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTrajectorySampleRange&    Trajectory                                             (Parm, NativeAccessSpecifierPublic)
// float                                   TraceHeight                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TraceHeightOffset                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ValidLengthToStart                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ValidMovePredictionLength                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ValidEdgeWidth                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AngleLimit                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOnlyLeft                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBunkerCollisionPoint            ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FBunkerCollisionPoint UMotionTrajectoryBlueprintLibrary::GetBunkerTrajectoryCollisionPoint(const class APawn* Actor, const struct FTrajectorySampleRange& Trajectory, float TraceHeight, float TraceHeightOffset, float ValidLengthToStart, float ValidMovePredictionLength, float ValidEdgeWidth, float AngleLimit, bool bOnlyLeft)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionTrajectoryBlueprintLibrary", "GetBunkerTrajectoryCollisionPoint");

	Params::MotionTrajectoryBlueprintLibrary_GetBunkerTrajectoryCollisionPoint Parms{};

	Parms.Actor = Actor;
	Parms.Trajectory = std::move(Trajectory);
	Parms.TraceHeight = TraceHeight;
	Parms.TraceHeightOffset = TraceHeightOffset;
	Parms.ValidLengthToStart = ValidLengthToStart;
	Parms.ValidMovePredictionLength = ValidMovePredictionLength;
	Parms.ValidEdgeWidth = ValidEdgeWidth;
	Parms.AngleLimit = AngleLimit;
	Parms.bOnlyLeft = bOnlyLeft;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MotionTrajectory.MotionTrajectoryBlueprintLibrary.GetCrossCollisionPointWithActorFaceDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class APawn*                      Actor                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TraceLength                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TraceHeight                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ValidLengthToStart                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ValidEdgeWidth                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AngleLimit                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOnlyLeft                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCrossCollisionPoint             ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FCrossCollisionPoint UMotionTrajectoryBlueprintLibrary::GetCrossCollisionPointWithActorFaceDir(const class APawn* Actor, float TraceLength, float TraceHeight, float ValidLengthToStart, float ValidEdgeWidth, float AngleLimit, bool bOnlyLeft)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionTrajectoryBlueprintLibrary", "GetCrossCollisionPointWithActorFaceDir");

	Params::MotionTrajectoryBlueprintLibrary_GetCrossCollisionPointWithActorFaceDir Parms{};

	Parms.Actor = Actor;
	Parms.TraceLength = TraceLength;
	Parms.TraceHeight = TraceHeight;
	Parms.ValidLengthToStart = ValidLengthToStart;
	Parms.ValidEdgeWidth = ValidEdgeWidth;
	Parms.AngleLimit = AngleLimit;
	Parms.bOnlyLeft = bOnlyLeft;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MotionTrajectory.MotionTrajectoryBlueprintLibrary.GetCrossTrajectoryCollisionPoint
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class APawn*                      Actor                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTrajectorySampleRange&    Trajectory                                             (Parm, NativeAccessSpecifierPublic)
// float                                   TraceLength                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TraceHeight                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ValidLengthToStart                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ValidMovePredictionLength                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ValidEdgeWidth                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AngleLimit                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOnlyLeft                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCrossCollisionPoint             ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FCrossCollisionPoint UMotionTrajectoryBlueprintLibrary::GetCrossTrajectoryCollisionPoint(const class APawn* Actor, const struct FTrajectorySampleRange& Trajectory, float TraceLength, float TraceHeight, float ValidLengthToStart, float ValidMovePredictionLength, float ValidEdgeWidth, float AngleLimit, bool bOnlyLeft)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionTrajectoryBlueprintLibrary", "GetCrossTrajectoryCollisionPoint");

	Params::MotionTrajectoryBlueprintLibrary_GetCrossTrajectoryCollisionPoint Parms{};

	Parms.Actor = Actor;
	Parms.Trajectory = std::move(Trajectory);
	Parms.TraceLength = TraceLength;
	Parms.TraceHeight = TraceHeight;
	Parms.ValidLengthToStart = ValidLengthToStart;
	Parms.ValidMovePredictionLength = ValidMovePredictionLength;
	Parms.ValidEdgeWidth = ValidEdgeWidth;
	Parms.AngleLimit = AngleLimit;
	Parms.bOnlyLeft = bOnlyLeft;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MotionTrajectory.MotionTrajectoryBlueprintLibrary.IsConstantSpeedTrajectory
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FTrajectorySampleRange&    Trajectory                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   Speed                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Tolerance                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMotionTrajectoryBlueprintLibrary::IsConstantSpeedTrajectory(const struct FTrajectorySampleRange& Trajectory, float Speed, float Tolerance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionTrajectoryBlueprintLibrary", "IsConstantSpeedTrajectory");

	Params::MotionTrajectoryBlueprintLibrary_IsConstantSpeedTrajectory Parms{};

	Parms.Trajectory = std::move(Trajectory);
	Parms.Speed = Speed;
	Parms.Tolerance = Tolerance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MotionTrajectory.MotionTrajectoryBlueprintLibrary.IsStartingTrajectory
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FTrajectorySampleRange&    Trajectory                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   MoveMinSpeed                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   IdleMaxSpeed                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMotionTrajectoryBlueprintLibrary::IsStartingTrajectory(const struct FTrajectorySampleRange& Trajectory, float MoveMinSpeed, float IdleMaxSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionTrajectoryBlueprintLibrary", "IsStartingTrajectory");

	Params::MotionTrajectoryBlueprintLibrary_IsStartingTrajectory Parms{};

	Parms.Trajectory = std::move(Trajectory);
	Parms.MoveMinSpeed = MoveMinSpeed;
	Parms.IdleMaxSpeed = IdleMaxSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MotionTrajectory.MotionTrajectoryBlueprintLibrary.IsStoppingTrajectory
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FTrajectorySampleRange&    Trajectory                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   MoveMinSpeed                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   IdleMaxSpeed                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMotionTrajectoryBlueprintLibrary::IsStoppingTrajectory(const struct FTrajectorySampleRange& Trajectory, float MoveMinSpeed, float IdleMaxSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionTrajectoryBlueprintLibrary", "IsStoppingTrajectory");

	Params::MotionTrajectoryBlueprintLibrary_IsStoppingTrajectory Parms{};

	Parms.Trajectory = std::move(Trajectory);
	Parms.MoveMinSpeed = MoveMinSpeed;
	Parms.IdleMaxSpeed = IdleMaxSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MotionTrajectory.MotionTrajectoryBlueprintLibrary.MakeTrajectoryRelativeToComponent
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FTrajectorySampleRange&    ActorTrajectory                                        (Parm, NativeAccessSpecifierPublic)
// const class USceneComponent*            Component                                              (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTrajectorySampleRange           ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FTrajectorySampleRange UMotionTrajectoryBlueprintLibrary::MakeTrajectoryRelativeToComponent(const struct FTrajectorySampleRange& ActorTrajectory, const class USceneComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionTrajectoryBlueprintLibrary", "MakeTrajectoryRelativeToComponent");

	Params::MotionTrajectoryBlueprintLibrary_MakeTrajectoryRelativeToComponent Parms{};

	Parms.ActorTrajectory = std::move(ActorTrajectory);
	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MotionTrajectory.MotionTrajectoryBlueprintLibrary.RotateTrajectory
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FTrajectorySampleRange&    Trajectory                                             (Parm, NativeAccessSpecifierPublic)
// const struct FQuat&                     Rotation                                               (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FTrajectorySampleRange           ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FTrajectorySampleRange UMotionTrajectoryBlueprintLibrary::RotateTrajectory(const struct FTrajectorySampleRange& Trajectory, const struct FQuat& Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionTrajectoryBlueprintLibrary", "RotateTrajectory");

	Params::MotionTrajectoryBlueprintLibrary_RotateTrajectory Parms{};

	Parms.Trajectory = std::move(Trajectory);
	Parms.Rotation = std::move(Rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}

}

