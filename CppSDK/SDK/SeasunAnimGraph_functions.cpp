#pragma once

/*
* SDK generated by Rei-SdkDumper
* Based on Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: SeasunAnimGraph

#include "Basic.hpp"

#include "SeasunAnimGraph_classes.hpp"
#include "SeasunAnimGraph_parameters.hpp"


namespace SDK
{

// Function SeasunAnimGraph.CurveSequenceControllerAnimInstance.ApplyStandardDirectionProcess
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UCurveSequenceAsset*              Curve                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UCurveSequenceControllerAnimInstance::ApplyStandardDirectionProcess(class UCurveSequenceAsset* Curve, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CurveSequenceControllerAnimInstance", "ApplyStandardDirectionProcess");

	Params::CurveSequenceControllerAnimInstance_ApplyStandardDirectionProcess Parms{};

	Parms.Curve = Curve;
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SeasunAnimGraph.CurveSequenceControllerAnimInstance.CurveSequence_Play
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class ICurveSequenceInterface>CurveSequenceToPlay                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
// float                                   InPlayRate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InTimeToStartCurveSequenceAt                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCurveSequenceControllerAnimInstance::CurveSequence_Play(TScriptInterface<class ICurveSequenceInterface> CurveSequenceToPlay, float InPlayRate, float InTimeToStartCurveSequenceAt)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CurveSequenceControllerAnimInstance", "CurveSequence_Play");

	Params::CurveSequenceControllerAnimInstance_CurveSequence_Play Parms{};

	Parms.CurveSequenceToPlay = CurveSequenceToPlay;
	Parms.InPlayRate = InPlayRate;
	Parms.InTimeToStartCurveSequenceAt = InTimeToStartCurveSequenceAt;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SeasunAnimGraph.CurveSequenceControllerAnimInstance.CurveSequence_Stop
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InBlendOutTime                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TScriptInterface<class ICurveSequenceInterface>CurveSequence                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)

void UCurveSequenceControllerAnimInstance::CurveSequence_Stop(float InBlendOutTime, const TScriptInterface<class ICurveSequenceInterface> CurveSequence)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CurveSequenceControllerAnimInstance", "CurveSequence_Stop");

	Params::CurveSequenceControllerAnimInstance_CurveSequence_Stop Parms{};

	Parms.InBlendOutTime = InBlendOutTime;
	Parms.CurveSequence = CurveSequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SeasunAnimGraph.CurveSequenceControllerAnimInstance.GetCustomPhysicMode
// (Final, Native, Public)
// Parameters:
// ECustomPhysicCalcMode                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECustomPhysicCalcMode UCurveSequenceControllerAnimInstance::GetCustomPhysicMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CurveSequenceControllerAnimInstance", "GetCustomPhysicMode");

	Params::CurveSequenceControllerAnimInstance_GetCustomPhysicMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SeasunAnimGraph.CurveSequenceControllerAnimInstance.GetCustomPhysicState
// (Final, Native, Public)
// Parameters:
// ECustomPhysicState                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECustomPhysicState UCurveSequenceControllerAnimInstance::GetCustomPhysicState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CurveSequenceControllerAnimInstance", "GetCustomPhysicState");

	Params::CurveSequenceControllerAnimInstance_GetCustomPhysicState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SeasunAnimGraph.CurveSequenceControllerAnimInstance.SetCustomPhysicMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECustomPhysicCalcMode                   InState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCurveSequenceControllerAnimInstance::SetCustomPhysicMode(ECustomPhysicCalcMode InState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CurveSequenceControllerAnimInstance", "SetCustomPhysicMode");

	Params::CurveSequenceControllerAnimInstance_SetCustomPhysicMode Parms{};

	Parms.InState = InState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SeasunAnimGraph.CurveSequenceControllerAnimInstance.SetCustomPhysicState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECustomPhysicState                      InState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCurveSequenceControllerAnimInstance::SetCustomPhysicState(ECustomPhysicState InState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CurveSequenceControllerAnimInstance", "SetCustomPhysicState");

	Params::CurveSequenceControllerAnimInstance_SetCustomPhysicState Parms{};

	Parms.InState = InState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SeasunAnimGraph.CurveSequenceControllerAnimInstance.CurveSequence_GetPosition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TScriptInterface<class ICurveSequenceInterface>CurveSequence                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCurveSequenceControllerAnimInstance::CurveSequence_GetPosition(TScriptInterface<class ICurveSequenceInterface> CurveSequence) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CurveSequenceControllerAnimInstance", "CurveSequence_GetPosition");

	Params::CurveSequenceControllerAnimInstance_CurveSequence_GetPosition Parms{};

	Parms.CurveSequence = CurveSequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SeasunAnimGraph.CurveSequenceControllerAnimInstance.CurveSequence_IsActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TScriptInterface<class ICurveSequenceInterface>CurveSequence                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCurveSequenceControllerAnimInstance::CurveSequence_IsActive(TScriptInterface<class ICurveSequenceInterface> CurveSequence) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CurveSequenceControllerAnimInstance", "CurveSequence_IsActive");

	Params::CurveSequenceControllerAnimInstance_CurveSequence_IsActive Parms{};

	Parms.CurveSequence = CurveSequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SeasunAnimGraph.CurveSequenceControllerAnimInstance.CurveSequence_IsPlaying
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TScriptInterface<class ICurveSequenceInterface>CurveSequence                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCurveSequenceControllerAnimInstance::CurveSequence_IsPlaying(TScriptInterface<class ICurveSequenceInterface> CurveSequence) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CurveSequenceControllerAnimInstance", "CurveSequence_IsPlaying");

	Params::CurveSequenceControllerAnimInstance_CurveSequence_IsPlaying Parms{};

	Parms.CurveSequence = CurveSequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SeasunAnimGraph.CurveSequenceControllerAnimInstance.HasCurveEffect
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCurveSequenceControllerAnimInstance::HasCurveEffect() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CurveSequenceControllerAnimInstance", "HasCurveEffect");

	Params::CurveSequenceControllerAnimInstance_HasCurveEffect Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SeasunAnimGraph.HitReactCondition.K2_Accepts
// (Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHitReactCondition::K2_Accepts(const struct FHitResult& Hit) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HitReactCondition", "K2_Accepts");

	Params::HitReactCondition_K2_Accepts Parms{};

	Parms.Hit = std::move(Hit);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SeasunAnimGraph.HitReactData.GetCaclHitDirectionFromHitResult
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// int32                                   WeaponType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHitReactData::GetCaclHitDirectionFromHitResult(const struct FHitResult& Hit, int32 WeaponType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HitReactData", "GetCaclHitDirectionFromHitResult");

	Params::HitReactData_GetCaclHitDirectionFromHitResult Parms{};

	Parms.Hit = std::move(Hit);
	Parms.WeaponType = WeaponType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SeasunAnimGraph.HitReactData.GetCurveSequenceFromHitResult
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// int32                                   WeaponType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveSequenceAsset*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCurveSequenceAsset* UHitReactData::GetCurveSequenceFromHitResult(const struct FHitResult& Hit, int32 WeaponType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HitReactData", "GetCurveSequenceFromHitResult");

	Params::HitReactData_GetCurveSequenceFromHitResult Parms{};

	Parms.Hit = std::move(Hit);
	Parms.WeaponType = WeaponType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SeasunAnimGraph.HitReactData.GetCurveSequencesFromHitResult
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// int32                                   WeaponType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UCurveSequenceAsset*>      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UCurveSequenceAsset*> UHitReactData::GetCurveSequencesFromHitResult(const struct FHitResult& Hit, int32 WeaponType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HitReactData", "GetCurveSequencesFromHitResult");

	Params::HitReactData_GetCurveSequencesFromHitResult Parms{};

	Parms.Hit = std::move(Hit);
	Parms.WeaponType = WeaponType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SeasunAnimGraph.AbnormalReactData.GetCurveSequenceFromAbnormalState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   InState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveSequenceAsset*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCurveSequenceAsset* UAbnormalReactData::GetCurveSequenceFromAbnormalState(uint8 InState) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbnormalReactData", "GetCurveSequenceFromAbnormalState");

	Params::AbnormalReactData_GetCurveSequenceFromAbnormalState Parms{};

	Parms.InState = InState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SeasunAnimGraph.AttributeAbnormalReactData.GetCurveSequenceFromAttributeAbnormalState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   InState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveSequenceAsset*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCurveSequenceAsset* UAttributeAbnormalReactData::GetCurveSequenceFromAttributeAbnormalState(uint8 InState) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttributeAbnormalReactData", "GetCurveSequenceFromAttributeAbnormalState");

	Params::AttributeAbnormalReactData_GetCurveSequenceFromAttributeAbnormalState Parms{};

	Parms.InState = InState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SeasunAnimGraph.PhysAnimLibrary.GetBodyNameByIndex
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class USkeletalMeshComponent*     Mesh                                                   (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            BodyName                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPhysAnimLibrary::GetBodyNameByIndex(const class USkeletalMeshComponent* Mesh, int32 Index_0, class FName* BodyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PhysAnimLibrary", "GetBodyNameByIndex");

	Params::PhysAnimLibrary_GetBodyNameByIndex Parms{};

	Parms.Mesh = Mesh;
	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (BodyName != nullptr)
		*BodyName = Parms.BodyName;

	return Parms.ReturnValue;
}


// Function SeasunAnimGraph.PhysAnimLibrary.ResetBoneSimulationInfo
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           Mesh                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysAnimLibrary::ResetBoneSimulationInfo(class USkeletalMeshComponent* Mesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PhysAnimLibrary", "ResetBoneSimulationInfo");

	Params::PhysAnimLibrary_ResetBoneSimulationInfo Parms{};

	Parms.Mesh = Mesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SeasunAnimGraph.PhysAnimLibrary.SetBodySimulateWeightByIndex
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           Mesh                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   BodyIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Weight                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysAnimLibrary::SetBodySimulateWeightByIndex(class USkeletalMeshComponent* Mesh, int32 BodyIndex, float Weight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PhysAnimLibrary", "SetBodySimulateWeightByIndex");

	Params::PhysAnimLibrary_SetBodySimulateWeightByIndex Parms{};

	Parms.Mesh = Mesh;
	Parms.BodyIndex = BodyIndex;
	Parms.Weight = Weight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SeasunAnimGraph.PhysAnimLibrary.SetBodySimulationWeight
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           Mesh                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      BoneName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Weight                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysAnimLibrary::SetBodySimulationWeight(class USkeletalMeshComponent* Mesh, const class FName& BoneName, float Weight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PhysAnimLibrary", "SetBodySimulationWeight");

	Params::PhysAnimLibrary_SetBodySimulationWeight Parms{};

	Parms.Mesh = Mesh;
	Parms.BoneName = BoneName;
	Parms.Weight = Weight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SeasunAnimGraph.PhysAnimLibrary.SetBoneSimulationInfo
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           Mesh                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitBoneSimulationInfo&    SimulationInfo                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FPhysAnimCharState*              CharPhysState                                          (Parm, OutParm, NativeAccessSpecifierPublic)

void UPhysAnimLibrary::SetBoneSimulationInfo(class USkeletalMeshComponent* Mesh, const struct FHitBoneSimulationInfo& SimulationInfo, struct FPhysAnimCharState* CharPhysState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PhysAnimLibrary", "SetBoneSimulationInfo");

	Params::PhysAnimLibrary_SetBoneSimulationInfo Parms{};

	Parms.Mesh = Mesh;
	Parms.SimulationInfo = std::move(SimulationInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (CharPhysState != nullptr)
		*CharPhysState = std::move(Parms.CharPhysState);
}


// Function SeasunAnimGraph.SeasunAnimFunctionLibrary.AngleBetweenVectors
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   v1                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   v2                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USeasunAnimFunctionLibrary::AngleBetweenVectors(const struct FVector& v1, const struct FVector& v2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SeasunAnimFunctionLibrary", "AngleBetweenVectors");

	Params::SeasunAnimFunctionLibrary_AngleBetweenVectors Parms{};

	Parms.v1 = std::move(v1);
	Parms.v2 = std::move(v2);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SeasunAnimGraph.SeasunAnimFunctionLibrary.ApplyRecoilForce
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FAnimRecoilSystem&         InRecoilSystem                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FRecoilStrength&           InStrength                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void USeasunAnimFunctionLibrary::ApplyRecoilForce(const struct FAnimRecoilSystem& InRecoilSystem, const struct FRecoilStrength& InStrength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SeasunAnimFunctionLibrary", "ApplyRecoilForce");

	Params::SeasunAnimFunctionLibrary_ApplyRecoilForce Parms{};

	Parms.InRecoilSystem = std::move(InRecoilSystem);
	Parms.InStrength = std::move(InStrength);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SeasunAnimGraph.SeasunAnimFunctionLibrary.CalculateAimRotation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UAnimInstance*                    AnimInstance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AimYaw                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AimPitch                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   FacingDirection                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RotationInterpSpeed                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxAngle                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OutPitch                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OutYaw                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ViewLocationSocketName                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USeasunAnimFunctionLibrary::CalculateAimRotation(class UAnimInstance* AnimInstance, float AimYaw, float AimPitch, float DeltaSeconds, const struct FVector& FacingDirection, float RotationInterpSpeed, float MaxAngle, float* OutPitch, float* OutYaw, class FName ViewLocationSocketName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SeasunAnimFunctionLibrary", "CalculateAimRotation");

	Params::SeasunAnimFunctionLibrary_CalculateAimRotation Parms{};

	Parms.AnimInstance = AnimInstance;
	Parms.AimYaw = AimYaw;
	Parms.AimPitch = AimPitch;
	Parms.DeltaSeconds = DeltaSeconds;
	Parms.FacingDirection = std::move(FacingDirection);
	Parms.RotationInterpSpeed = RotationInterpSpeed;
	Parms.MaxAngle = MaxAngle;
	Parms.ViewLocationSocketName = ViewLocationSocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPitch != nullptr)
		*OutPitch = Parms.OutPitch;

	if (OutYaw != nullptr)
		*OutYaw = Parms.OutYaw;
}


// Function SeasunAnimGraph.SeasunAnimFunctionLibrary.CalculateDirection
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   Vector                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  BaseRotation                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USeasunAnimFunctionLibrary::CalculateDirection(const struct FVector& Vector, const struct FRotator& BaseRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SeasunAnimFunctionLibrary", "CalculateDirection");

	Params::SeasunAnimFunctionLibrary_CalculateDirection Parms{};

	Parms.Vector = std::move(Vector);
	Parms.BaseRotation = std::move(BaseRotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SeasunAnimGraph.SeasunAnimFunctionLibrary.GetLerpedTimeByCurveValueFromAnimMontage
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class UAnimMontage*               AnimMontage                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      SectionName                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      CurveName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CurveValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OutTime                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUnsigned                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USeasunAnimFunctionLibrary::GetLerpedTimeByCurveValueFromAnimMontage(const class UAnimMontage* AnimMontage, const class FName& SectionName, const class FName& CurveName, float CurveValue, float* OutTime, bool bUnsigned)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SeasunAnimFunctionLibrary", "GetLerpedTimeByCurveValueFromAnimMontage");

	Params::SeasunAnimFunctionLibrary_GetLerpedTimeByCurveValueFromAnimMontage Parms{};

	Parms.AnimMontage = AnimMontage;
	Parms.SectionName = SectionName;
	Parms.CurveName = CurveName;
	Parms.CurveValue = CurveValue;
	Parms.bUnsigned = bUnsigned;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTime != nullptr)
		*OutTime = Parms.OutTime;

	return Parms.ReturnValue;
}


// Function SeasunAnimGraph.SeasunAnimFunctionLibrary.GetLerpedTimeByCurveValueFromAnimSequence
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class UAnimSequenceBase*          AnimSequence                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      CurveName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CurveValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OutTime                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUnsigned                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USeasunAnimFunctionLibrary::GetLerpedTimeByCurveValueFromAnimSequence(const class UAnimSequenceBase* AnimSequence, const class FName& CurveName, float CurveValue, float* OutTime, bool bUnsigned)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SeasunAnimFunctionLibrary", "GetLerpedTimeByCurveValueFromAnimSequence");

	Params::SeasunAnimFunctionLibrary_GetLerpedTimeByCurveValueFromAnimSequence Parms{};

	Parms.AnimSequence = AnimSequence;
	Parms.CurveName = CurveName;
	Parms.CurveValue = CurveValue;
	Parms.bUnsigned = bUnsigned;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTime != nullptr)
		*OutTime = Parms.OutTime;

	return Parms.ReturnValue;
}


// Function SeasunAnimGraph.SeasunAnimFunctionLibrary.GetSavedBoneTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimInstance*                    AnimInstance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      GroupName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      BoneName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform USeasunAnimFunctionLibrary::GetSavedBoneTransform(class UAnimInstance* AnimInstance, const class FName& GroupName, const class FName& BoneName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SeasunAnimFunctionLibrary", "GetSavedBoneTransform");

	Params::SeasunAnimFunctionLibrary_GetSavedBoneTransform Parms{};

	Parms.AnimInstance = AnimInstance;
	Parms.GroupName = GroupName;
	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SeasunAnimGraph.SeasunAnimFunctionLibrary.HasSavedBoneTransform
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimInstance*                    AnimInstance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      GroupName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      BoneName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USeasunAnimFunctionLibrary::HasSavedBoneTransform(class UAnimInstance* AnimInstance, const class FName& GroupName, const class FName& BoneName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SeasunAnimFunctionLibrary", "HasSavedBoneTransform");

	Params::SeasunAnimFunctionLibrary_HasSavedBoneTransform Parms{};

	Parms.AnimInstance = AnimInstance;
	Parms.GroupName = GroupName;
	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SeasunAnimGraph.SeasunAnimFunctionLibrary.PlayLoopSlotAnimationAsDynamicMontage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimInstance*                    AnimInstance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                Asset                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SlotNodeName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartLoopTime                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EndLoopTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendInTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendOutTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InPlayRate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendOutTriggerTime                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InTimeToStartMontageAt                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* USeasunAnimFunctionLibrary::PlayLoopSlotAnimationAsDynamicMontage(class UAnimInstance* AnimInstance, class UAnimSequenceBase* Asset, class FName SlotNodeName, float StartLoopTime, float EndLoopTime, float BlendInTime, float BlendOutTime, float InPlayRate, float BlendOutTriggerTime, float InTimeToStartMontageAt)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SeasunAnimFunctionLibrary", "PlayLoopSlotAnimationAsDynamicMontage");

	Params::SeasunAnimFunctionLibrary_PlayLoopSlotAnimationAsDynamicMontage Parms{};

	Parms.AnimInstance = AnimInstance;
	Parms.Asset = Asset;
	Parms.SlotNodeName = SlotNodeName;
	Parms.StartLoopTime = StartLoopTime;
	Parms.EndLoopTime = EndLoopTime;
	Parms.BlendInTime = BlendInTime;
	Parms.BlendOutTime = BlendOutTime;
	Parms.InPlayRate = InPlayRate;
	Parms.BlendOutTriggerTime = BlendOutTriggerTime;
	Parms.InTimeToStartMontageAt = InTimeToStartMontageAt;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SeasunAnimGraph.SeasunAnimFunctionLibrary.PlaySlotAnimationWithLoopCountAsDynamicMontage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimInstance*                    AnimInstance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                Asset                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SlotNodeName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartLoopTime                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EndLoopTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LoopCount                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendInTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendOutTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InPlayRate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendOutTriggerTime                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InTimeToStartMontageAt                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* USeasunAnimFunctionLibrary::PlaySlotAnimationWithLoopCountAsDynamicMontage(class UAnimInstance* AnimInstance, class UAnimSequenceBase* Asset, class FName SlotNodeName, float StartLoopTime, float EndLoopTime, int32 LoopCount, float BlendInTime, float BlendOutTime, float InPlayRate, float BlendOutTriggerTime, float InTimeToStartMontageAt)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SeasunAnimFunctionLibrary", "PlaySlotAnimationWithLoopCountAsDynamicMontage");

	Params::SeasunAnimFunctionLibrary_PlaySlotAnimationWithLoopCountAsDynamicMontage Parms{};

	Parms.AnimInstance = AnimInstance;
	Parms.Asset = Asset;
	Parms.SlotNodeName = SlotNodeName;
	Parms.StartLoopTime = StartLoopTime;
	Parms.EndLoopTime = EndLoopTime;
	Parms.LoopCount = LoopCount;
	Parms.BlendInTime = BlendInTime;
	Parms.BlendOutTime = BlendOutTime;
	Parms.InPlayRate = InPlayRate;
	Parms.BlendOutTriggerTime = BlendOutTriggerTime;
	Parms.InTimeToStartMontageAt = InTimeToStartMontageAt;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SeasunAnimGraph.SeasunAnimFunctionLibrary.UpdateRecoilSystem
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FAnimRecoilSystem&         InRecoilSystem                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   InDeltaSeconds                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         OutGunTransition                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator*                        OutGunRotation                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float*                                  OutPelvisOffset                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OutSpineRotationAngle                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OutRightShoulderRotationAngle                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OutLeftShoulderRotationAngle                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USeasunAnimFunctionLibrary::UpdateRecoilSystem(const struct FAnimRecoilSystem& InRecoilSystem, float InDeltaSeconds, struct FVector* OutGunTransition, struct FRotator* OutGunRotation, float* OutPelvisOffset, float* OutSpineRotationAngle, float* OutRightShoulderRotationAngle, float* OutLeftShoulderRotationAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SeasunAnimFunctionLibrary", "UpdateRecoilSystem");

	Params::SeasunAnimFunctionLibrary_UpdateRecoilSystem Parms{};

	Parms.InRecoilSystem = std::move(InRecoilSystem);
	Parms.InDeltaSeconds = InDeltaSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutGunTransition != nullptr)
		*OutGunTransition = std::move(Parms.OutGunTransition);

	if (OutGunRotation != nullptr)
		*OutGunRotation = std::move(Parms.OutGunRotation);

	if (OutPelvisOffset != nullptr)
		*OutPelvisOffset = Parms.OutPelvisOffset;

	if (OutSpineRotationAngle != nullptr)
		*OutSpineRotationAngle = Parms.OutSpineRotationAngle;

	if (OutRightShoulderRotationAngle != nullptr)
		*OutRightShoulderRotationAngle = Parms.OutRightShoulderRotationAngle;

	if (OutLeftShoulderRotationAngle != nullptr)
		*OutLeftShoulderRotationAngle = Parms.OutLeftShoulderRotationAngle;
}

}

